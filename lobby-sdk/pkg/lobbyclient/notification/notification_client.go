// Code generated by go-swagger; DO NOT EDIT.

package notification

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new notification API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for notification API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreateNotificationTemplateV1Admin(params *CreateNotificationTemplateV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNotificationTemplateV1AdminNoContent, *CreateNotificationTemplateV1AdminBadRequest, *CreateNotificationTemplateV1AdminUnauthorized, *CreateNotificationTemplateV1AdminForbidden, *CreateNotificationTemplateV1AdminNotFound, *CreateNotificationTemplateV1AdminConflict, error)

	CreateNotificationTopicV1Admin(params *CreateNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNotificationTopicV1AdminNoContent, *CreateNotificationTopicV1AdminBadRequest, *CreateNotificationTopicV1AdminUnauthorized, *CreateNotificationTopicV1AdminForbidden, error)

	CreateTemplate(params *CreateTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTemplateNoContent, *CreateTemplateBadRequest, *CreateTemplateUnauthorized, *CreateTemplateForbidden, *CreateTemplateNotFound, error)

	CreateTopic(params *CreateTopicParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTopicCreated, *CreateTopicBadRequest, *CreateTopicUnauthorized, *CreateTopicForbidden, *CreateTopicConflict, error)

	DeleteNotificationTemplateSlugV1Admin(params *DeleteNotificationTemplateSlugV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNotificationTemplateSlugV1AdminNoContent, *DeleteNotificationTemplateSlugV1AdminBadRequest, *DeleteNotificationTemplateSlugV1AdminUnauthorized, *DeleteNotificationTemplateSlugV1AdminForbidden, *DeleteNotificationTemplateSlugV1AdminNotFound, error)

	DeleteNotificationTopicV1Admin(params *DeleteNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNotificationTopicV1AdminNoContent, *DeleteNotificationTopicV1AdminUnauthorized, *DeleteNotificationTopicV1AdminForbidden, *DeleteNotificationTopicV1AdminNotFound, *DeleteNotificationTopicV1AdminInternalServerError, error)

	DeleteTemplateLocalization(params *DeleteTemplateLocalizationParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateLocalizationNoContent, *DeleteTemplateLocalizationBadRequest, *DeleteTemplateLocalizationUnauthorized, *DeleteTemplateLocalizationForbidden, *DeleteTemplateLocalizationNotFound, error)

	DeleteTemplateLocalizationV1Admin(params *DeleteTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateLocalizationV1AdminNoContent, *DeleteTemplateLocalizationV1AdminUnauthorized, *DeleteTemplateLocalizationV1AdminForbidden, *DeleteTemplateLocalizationV1AdminNotFound, *DeleteTemplateLocalizationV1AdminInternalServerError, error)

	DeleteTemplateSlug(params *DeleteTemplateSlugParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateSlugNoContent, *DeleteTemplateSlugBadRequest, *DeleteTemplateSlugUnauthorized, *DeleteTemplateSlugForbidden, *DeleteTemplateSlugNotFound, error)

	DeleteTopicByTopicName(params *DeleteTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTopicByTopicNameNoContent, *DeleteTopicByTopicNameUnauthorized, *DeleteTopicByTopicNameForbidden, *DeleteTopicByTopicNameNotFound, *DeleteTopicByTopicNameInternalServerError, error)

	FreeFormNotification(params *FreeFormNotificationParams, authInfo runtime.ClientAuthInfoWriter) (*FreeFormNotificationAccepted, *FreeFormNotificationBadRequest, *FreeFormNotificationUnauthorized, *FreeFormNotificationForbidden, *FreeFormNotificationNotFound, error)

	FreeFormNotificationByUserID(params *FreeFormNotificationByUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*FreeFormNotificationByUserIDNoContent, *FreeFormNotificationByUserIDBadRequest, *FreeFormNotificationByUserIDUnauthorized, *FreeFormNotificationByUserIDForbidden, *FreeFormNotificationByUserIDNotFound, error)

	GetAllNotificationTemplatesV1Admin(params *GetAllNotificationTemplatesV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllNotificationTemplatesV1AdminOK, *GetAllNotificationTemplatesV1AdminBadRequest, *GetAllNotificationTemplatesV1AdminUnauthorized, *GetAllNotificationTemplatesV1AdminForbidden, *GetAllNotificationTemplatesV1AdminNotFound, *GetAllNotificationTemplatesV1AdminInternalServerError, error)

	GetAllNotificationTopicsV1Admin(params *GetAllNotificationTopicsV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllNotificationTopicsV1AdminOK, *GetAllNotificationTopicsV1AdminUnauthorized, *GetAllNotificationTopicsV1AdminForbidden, *GetAllNotificationTopicsV1AdminNotFound, *GetAllNotificationTopicsV1AdminInternalServerError, error)

	GetAllStoredNotificationsV1(params *GetAllStoredNotificationsV1Params, authInfo runtime.ClientAuthInfoWriter) (*GetAllStoredNotificationsV1OK, *GetAllStoredNotificationsV1BadRequest, *GetAllStoredNotificationsV1Unauthorized, *GetAllStoredNotificationsV1Forbidden, *GetAllStoredNotificationsV1NotFound, error)

	GetGameTemplate(params *GetGameTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameTemplateOK, *GetGameTemplateBadRequest, *GetGameTemplateUnauthorized, *GetGameTemplateForbidden, *GetGameTemplateNotFound, error)

	GetLocalizationTemplate(params *GetLocalizationTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocalizationTemplateOK, *GetLocalizationTemplateBadRequest, *GetLocalizationTemplateUnauthorized, *GetLocalizationTemplateForbidden, *GetLocalizationTemplateNotFound, error)

	GetNotificationTopicV1Admin(params *GetNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetNotificationTopicV1AdminOK, *GetNotificationTopicV1AdminUnauthorized, *GetNotificationTopicV1AdminForbidden, *GetNotificationTopicV1AdminNotFound, *GetNotificationTopicV1AdminInternalServerError, error)

	GetNotifications(params *GetNotificationsParams, authInfo runtime.ClientAuthInfoWriter) (*GetNotificationsOK, *GetNotificationsBadRequest, *GetNotificationsUnauthorized, *GetNotificationsForbidden, *GetNotificationsNotFound, error)

	GetSingleTemplateLocalizationV1Admin(params *GetSingleTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetSingleTemplateLocalizationV1AdminOK, *GetSingleTemplateLocalizationV1AdminUnauthorized, *GetSingleTemplateLocalizationV1AdminForbidden, *GetSingleTemplateLocalizationV1AdminNotFound, *GetSingleTemplateLocalizationV1AdminInternalServerError, error)

	GetSlugTemplate(params *GetSlugTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetSlugTemplateOK, *GetSlugTemplateBadRequest, *GetSlugTemplateUnauthorized, *GetSlugTemplateForbidden, *GetSlugTemplateNotFound, error)

	GetTemplateSlugLocalizationsTemplateV1Admin(params *GetTemplateSlugLocalizationsTemplateV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetTemplateSlugLocalizationsTemplateV1AdminOK, *GetTemplateSlugLocalizationsTemplateV1AdminBadRequest, *GetTemplateSlugLocalizationsTemplateV1AdminUnauthorized, *GetTemplateSlugLocalizationsTemplateV1AdminForbidden, *GetTemplateSlugLocalizationsTemplateV1AdminNotFound, error)

	GetTopicByNamespace(params *GetTopicByNamespaceParams, authInfo runtime.ClientAuthInfoWriter) (*GetTopicByNamespaceOK, *GetTopicByNamespaceUnauthorized, *GetTopicByNamespaceForbidden, *GetTopicByNamespaceNotFound, *GetTopicByNamespaceInternalServerError, error)

	GetTopicByTopicName(params *GetTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetTopicByTopicNameOK, *GetTopicByTopicNameUnauthorized, *GetTopicByTopicNameForbidden, *GetTopicByTopicNameNotFound, *GetTopicByTopicNameInternalServerError, error)

	NotificationWithTemplate(params *NotificationWithTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*NotificationWithTemplateAccepted, *NotificationWithTemplateBadRequest, *NotificationWithTemplateUnauthorized, *NotificationWithTemplateForbidden, *NotificationWithTemplateNotFound, error)

	NotificationWithTemplateByUserID(params *NotificationWithTemplateByUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*NotificationWithTemplateByUserIDNoContent, *NotificationWithTemplateByUserIDBadRequest, *NotificationWithTemplateByUserIDUnauthorized, *NotificationWithTemplateByUserIDForbidden, *NotificationWithTemplateByUserIDNotFound, error)

	PublishTemplate(params *PublishTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*PublishTemplateNoContent, *PublishTemplateBadRequest, *PublishTemplateUnauthorized, *PublishTemplateForbidden, *PublishTemplateNotFound, error)

	PublishTemplateLocalizationV1Admin(params *PublishTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*PublishTemplateLocalizationV1AdminNoContent, *PublishTemplateLocalizationV1AdminUnauthorized, *PublishTemplateLocalizationV1AdminForbidden, *PublishTemplateLocalizationV1AdminNotFound, *PublishTemplateLocalizationV1AdminInternalServerError, error)

	SendMultipleUsersFreeformNotificationV1Admin(params *SendMultipleUsersFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendMultipleUsersFreeformNotificationV1AdminNoContent, *SendMultipleUsersFreeformNotificationV1AdminBadRequest, *SendMultipleUsersFreeformNotificationV1AdminUnauthorized, *SendMultipleUsersFreeformNotificationV1AdminForbidden, error)

	SendSpecificUserFreeformNotificationV1Admin(params *SendSpecificUserFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendSpecificUserFreeformNotificationV1AdminNoContent, *SendSpecificUserFreeformNotificationV1AdminBadRequest, *SendSpecificUserFreeformNotificationV1AdminUnauthorized, *SendSpecificUserFreeformNotificationV1AdminForbidden, *SendSpecificUserFreeformNotificationV1AdminNotFound, error)

	SendSpecificUserTemplatedNotificationV1Admin(params *SendSpecificUserTemplatedNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendSpecificUserTemplatedNotificationV1AdminNoContent, *SendSpecificUserTemplatedNotificationV1AdminBadRequest, *SendSpecificUserTemplatedNotificationV1AdminUnauthorized, *SendSpecificUserTemplatedNotificationV1AdminForbidden, *SendSpecificUserTemplatedNotificationV1AdminNotFound, error)

	SendUsersFreeformNotificationV1Admin(params *SendUsersFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendUsersFreeformNotificationV1AdminAccepted, *SendUsersFreeformNotificationV1AdminBadRequest, *SendUsersFreeformNotificationV1AdminUnauthorized, *SendUsersFreeformNotificationV1AdminForbidden, *SendUsersFreeformNotificationV1AdminNotFound, error)

	SendUsersTemplatedNotificationV1Admin(params *SendUsersTemplatedNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendUsersTemplatedNotificationV1AdminAccepted, *SendUsersTemplatedNotificationV1AdminBadRequest, *SendUsersTemplatedNotificationV1AdminUnauthorized, *SendUsersTemplatedNotificationV1AdminForbidden, *SendUsersTemplatedNotificationV1AdminNotFound, error)

	UpdateLocalizationTemplate(params *UpdateLocalizationTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateLocalizationTemplateNoContent, *UpdateLocalizationTemplateBadRequest, *UpdateLocalizationTemplateUnauthorized, *UpdateLocalizationTemplateForbidden, *UpdateLocalizationTemplateNotFound, error)

	UpdateNotificationTopicV1Admin(params *UpdateNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateNotificationTopicV1AdminNoContent, *UpdateNotificationTopicV1AdminBadRequest, *UpdateNotificationTopicV1AdminUnauthorized, *UpdateNotificationTopicV1AdminForbidden, *UpdateNotificationTopicV1AdminNotFound, *UpdateNotificationTopicV1AdminInternalServerError, error)

	UpdateTemplateLocalizationV1Admin(params *UpdateTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateTemplateLocalizationV1AdminNoContent, *UpdateTemplateLocalizationV1AdminBadRequest, *UpdateTemplateLocalizationV1AdminUnauthorized, *UpdateTemplateLocalizationV1AdminForbidden, *UpdateTemplateLocalizationV1AdminNotFound, *UpdateTemplateLocalizationV1AdminInternalServerError, error)

	UpdateTopicByTopicName(params *UpdateTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateTopicByTopicNameNoContent, *UpdateTopicByTopicNameUnauthorized, *UpdateTopicByTopicNameForbidden, *UpdateTopicByTopicNameNotFound, *UpdateTopicByTopicNameInternalServerError, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreateNotificationTemplateV1Admin creates new notification template

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside
			handlebars will be the key to be replaced when sending notification. Already existing template with the same
			slug and language can not be created.
			<br>Check model description for detailed input restrictions.<br>
			Action Code: 50204
*/
func (a *Client) CreateNotificationTemplateV1Admin(params *CreateNotificationTemplateV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNotificationTemplateV1AdminNoContent, *CreateNotificationTemplateV1AdminBadRequest, *CreateNotificationTemplateV1AdminUnauthorized, *CreateNotificationTemplateV1AdminForbidden, *CreateNotificationTemplateV1AdminNotFound, *CreateNotificationTemplateV1AdminConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateNotificationTemplateV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createNotificationTemplateV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateNotificationTemplateV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateNotificationTemplateV1AdminNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *CreateNotificationTemplateV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *CreateNotificationTemplateV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *CreateNotificationTemplateV1AdminForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *CreateNotificationTemplateV1AdminNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *CreateNotificationTemplateV1AdminConflict:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateNotificationTopicV1Admin creates new notification topic

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Create new notification topic.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created<br/>
			Action Code: 50214
*/
func (a *Client) CreateNotificationTopicV1Admin(params *CreateNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNotificationTopicV1AdminNoContent, *CreateNotificationTopicV1AdminBadRequest, *CreateNotificationTopicV1AdminUnauthorized, *CreateNotificationTopicV1AdminForbidden, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateNotificationTopicV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createNotificationTopicV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateNotificationTopicV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateNotificationTopicV1AdminNoContent:
		return v, nil, nil, nil, nil
	case *CreateNotificationTopicV1AdminBadRequest:
		return nil, v, nil, nil, nil
	case *CreateNotificationTopicV1AdminUnauthorized:
		return nil, nil, v, nil, nil
	case *CreateNotificationTopicV1AdminForbidden:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateTemplate creates new notification template

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [CREATE]</code> with scope <code>social</code>
			<br>Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside
			handlebars will be the key to be replaced when sending notification. Already existing template with the same
			slug and language can not be created.
			<br>Check model description for detailed input restrictions.
*/
func (a *Client) CreateTemplate(params *CreateTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTemplateNoContent, *CreateTemplateBadRequest, *CreateTemplateUnauthorized, *CreateTemplateForbidden, *CreateTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createTemplate",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateTemplateNoContent:
		return v, nil, nil, nil, nil, nil
	case *CreateTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *CreateTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *CreateTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *CreateTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateTopic creates new notification topic

  Required permission : <code>NAMESPACE:{namespace}:TOPIC [CREATE]</code> with scope <code>social</code>
			<br>Create new notification topic.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created
*/
func (a *Client) CreateTopic(params *CreateTopicParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTopicCreated, *CreateTopicBadRequest, *CreateTopicUnauthorized, *CreateTopicForbidden, *CreateTopicConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTopicParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createTopic",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateTopicCreated:
		return v, nil, nil, nil, nil, nil
	case *CreateTopicBadRequest:
		return nil, v, nil, nil, nil, nil
	case *CreateTopicUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *CreateTopicForbidden:
		return nil, nil, nil, v, nil, nil
	case *CreateTopicConflict:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteNotificationTemplateSlugV1Admin deletes template slug in notification template

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [DELETE]</code> with scope <code>social</code>
			<br>Delete template slug in notification template<br>
			Action Code: 50206
*/
func (a *Client) DeleteNotificationTemplateSlugV1Admin(params *DeleteNotificationTemplateSlugV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNotificationTemplateSlugV1AdminNoContent, *DeleteNotificationTemplateSlugV1AdminBadRequest, *DeleteNotificationTemplateSlugV1AdminUnauthorized, *DeleteNotificationTemplateSlugV1AdminForbidden, *DeleteNotificationTemplateSlugV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteNotificationTemplateSlugV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteNotificationTemplateSlugV1Admin",
		Method:             "DELETE",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteNotificationTemplateSlugV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteNotificationTemplateSlugV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteNotificationTemplateSlugV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *DeleteNotificationTemplateSlugV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *DeleteNotificationTemplateSlugV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *DeleteNotificationTemplateSlugV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteNotificationTopicV1Admin deletes topic information by topic name

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [DELETE]</code> with scope <code>social</code>
			<br>delete topic information by topic name.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created <br/>
			Action Code: 50217
*/
func (a *Client) DeleteNotificationTopicV1Admin(params *DeleteNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNotificationTopicV1AdminNoContent, *DeleteNotificationTopicV1AdminUnauthorized, *DeleteNotificationTopicV1AdminForbidden, *DeleteNotificationTopicV1AdminNotFound, *DeleteNotificationTopicV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteNotificationTopicV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteNotificationTopicV1Admin",
		Method:             "DELETE",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteNotificationTopicV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteNotificationTopicV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteNotificationTopicV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *DeleteNotificationTopicV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *DeleteNotificationTopicV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *DeleteNotificationTopicV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteTemplateLocalization deletes template localization

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [DELETE]</code> with scope <code>social</code>
			<br>Delete all template in a slug
*/
func (a *Client) DeleteTemplateLocalization(params *DeleteTemplateLocalizationParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateLocalizationNoContent, *DeleteTemplateLocalizationBadRequest, *DeleteTemplateLocalizationUnauthorized, *DeleteTemplateLocalizationForbidden, *DeleteTemplateLocalizationNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTemplateLocalizationParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTemplateLocalization",
		Method:             "DELETE",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTemplateLocalizationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteTemplateLocalizationNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteTemplateLocalizationBadRequest:
		return nil, v, nil, nil, nil, nil
	case *DeleteTemplateLocalizationUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *DeleteTemplateLocalizationForbidden:
		return nil, nil, nil, v, nil, nil
	case *DeleteTemplateLocalizationNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteTemplateLocalizationV1Admin deletes template localization

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [DELETE]</code> with scope <code>social</code>
			<br>delete template localization<br/>
			Action Code: 50209
*/
func (a *Client) DeleteTemplateLocalizationV1Admin(params *DeleteTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateLocalizationV1AdminNoContent, *DeleteTemplateLocalizationV1AdminUnauthorized, *DeleteTemplateLocalizationV1AdminForbidden, *DeleteTemplateLocalizationV1AdminNotFound, *DeleteTemplateLocalizationV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTemplateLocalizationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTemplateLocalizationV1Admin",
		Method:             "DELETE",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTemplateLocalizationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteTemplateLocalizationV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteTemplateLocalizationV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *DeleteTemplateLocalizationV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *DeleteTemplateLocalizationV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *DeleteTemplateLocalizationV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteTemplateSlug deletes template localization

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [DELETE]</code> with scope <code>social</code>
			<br>Delete localization template
*/
func (a *Client) DeleteTemplateSlug(params *DeleteTemplateSlugParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTemplateSlugNoContent, *DeleteTemplateSlugBadRequest, *DeleteTemplateSlugUnauthorized, *DeleteTemplateSlugForbidden, *DeleteTemplateSlugNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTemplateSlugParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTemplateSlug",
		Method:             "DELETE",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTemplateSlugReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteTemplateSlugNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteTemplateSlugBadRequest:
		return nil, v, nil, nil, nil, nil
	case *DeleteTemplateSlugUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *DeleteTemplateSlugForbidden:
		return nil, nil, nil, v, nil, nil
	case *DeleteTemplateSlugNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteTopicByTopicName deletes topic information by topic name

  Required permission : <code>NAMESPACE:{namespace}:TOPIC [DELETE]</code> with scope <code>social</code>
			<br>delete topic information by topic name.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created
*/
func (a *Client) DeleteTopicByTopicName(params *DeleteTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTopicByTopicNameNoContent, *DeleteTopicByTopicNameUnauthorized, *DeleteTopicByTopicNameForbidden, *DeleteTopicByTopicNameNotFound, *DeleteTopicByTopicNameInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTopicByTopicNameParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTopicByTopicName",
		Method:             "DELETE",
		PathPattern:        "/notification/namespaces/{namespace}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTopicByTopicNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteTopicByTopicNameNoContent:
		return v, nil, nil, nil, nil, nil
	case *DeleteTopicByTopicNameUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *DeleteTopicByTopicNameForbidden:
		return nil, nil, v, nil, nil, nil
	case *DeleteTopicByTopicNameNotFound:
		return nil, nil, nil, v, nil, nil
	case *DeleteTopicByTopicNameInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  FreeFormNotification sends freeform notification to a user

  Required permission : <code>NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to all connected users in a namespace.
*/
func (a *Client) FreeFormNotification(params *FreeFormNotificationParams, authInfo runtime.ClientAuthInfoWriter) (*FreeFormNotificationAccepted, *FreeFormNotificationBadRequest, *FreeFormNotificationUnauthorized, *FreeFormNotificationForbidden, *FreeFormNotificationNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFreeFormNotificationParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "freeFormNotification",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/freeform",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FreeFormNotificationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *FreeFormNotificationAccepted:
		return v, nil, nil, nil, nil, nil
	case *FreeFormNotificationBadRequest:
		return nil, v, nil, nil, nil, nil
	case *FreeFormNotificationUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *FreeFormNotificationForbidden:
		return nil, nil, nil, v, nil, nil
	case *FreeFormNotificationNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  FreeFormNotificationByUserID sends freeform notification to a user

  Required permission : <code>NAMESPACE:{namespace}:USER:{userId}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to a user. There are two types of notification: sync and async. Async message will be stored
			to database if the receiver is offline. This stored message could be retrieved later via websocket command.
*/
func (a *Client) FreeFormNotificationByUserID(params *FreeFormNotificationByUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*FreeFormNotificationByUserIDNoContent, *FreeFormNotificationByUserIDBadRequest, *FreeFormNotificationByUserIDUnauthorized, *FreeFormNotificationByUserIDForbidden, *FreeFormNotificationByUserIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFreeFormNotificationByUserIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "freeFormNotificationByUserID",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/users/{userId}/freeform",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FreeFormNotificationByUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *FreeFormNotificationByUserIDNoContent:
		return v, nil, nil, nil, nil, nil
	case *FreeFormNotificationByUserIDBadRequest:
		return nil, v, nil, nil, nil, nil
	case *FreeFormNotificationByUserIDUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *FreeFormNotificationByUserIDForbidden:
		return nil, nil, nil, v, nil, nil
	case *FreeFormNotificationByUserIDNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllNotificationTemplatesV1Admin gets all notification template in a namespace

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>Get all templates in a namespace<br>
			Action Code: 50203
*/
func (a *Client) GetAllNotificationTemplatesV1Admin(params *GetAllNotificationTemplatesV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllNotificationTemplatesV1AdminOK, *GetAllNotificationTemplatesV1AdminBadRequest, *GetAllNotificationTemplatesV1AdminUnauthorized, *GetAllNotificationTemplatesV1AdminForbidden, *GetAllNotificationTemplatesV1AdminNotFound, *GetAllNotificationTemplatesV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllNotificationTemplatesV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAllNotificationTemplatesV1Admin",
		Method:             "GET",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllNotificationTemplatesV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllNotificationTemplatesV1AdminOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetAllNotificationTemplatesV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetAllNotificationTemplatesV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetAllNotificationTemplatesV1AdminForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetAllNotificationTemplatesV1AdminNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetAllNotificationTemplatesV1AdminInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllNotificationTopicsV1Admin gets topic by namespace

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>get topic by namespace.<br/>
			Action Code: 50213
*/
func (a *Client) GetAllNotificationTopicsV1Admin(params *GetAllNotificationTopicsV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllNotificationTopicsV1AdminOK, *GetAllNotificationTopicsV1AdminUnauthorized, *GetAllNotificationTopicsV1AdminForbidden, *GetAllNotificationTopicsV1AdminNotFound, *GetAllNotificationTopicsV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllNotificationTopicsV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAllNotificationTopicsV1Admin",
		Method:             "GET",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllNotificationTopicsV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllNotificationTopicsV1AdminOK:
		return v, nil, nil, nil, nil, nil
	case *GetAllNotificationTopicsV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *GetAllNotificationTopicsV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *GetAllNotificationTopicsV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *GetAllNotificationTopicsV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllStoredNotificationsV1 gets all stored notification for a user

  Required valid user authorization
			<br>Retrieve all notification stored for a user. Successfully retrieved notifications will not be deleted.
*/
func (a *Client) GetAllStoredNotificationsV1(params *GetAllStoredNotificationsV1Params, authInfo runtime.ClientAuthInfoWriter) (*GetAllStoredNotificationsV1OK, *GetAllStoredNotificationsV1BadRequest, *GetAllStoredNotificationsV1Unauthorized, *GetAllStoredNotificationsV1Forbidden, *GetAllStoredNotificationsV1NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllStoredNotificationsV1Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAllStoredNotificationsV1",
		Method:             "GET",
		PathPattern:        "/lobby/v1/public/notification/namespaces/{namespace}/users/me",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllStoredNotificationsV1Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllStoredNotificationsV1OK:
		return v, nil, nil, nil, nil, nil
	case *GetAllStoredNotificationsV1BadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetAllStoredNotificationsV1Unauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetAllStoredNotificationsV1Forbidden:
		return nil, nil, nil, v, nil, nil
	case *GetAllStoredNotificationsV1NotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetGameTemplate gets all notification template in a namespace

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [READ]</code> with scope <code>social</code>
			<br>Get all templates in a namespace
*/
func (a *Client) GetGameTemplate(params *GetGameTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameTemplateOK, *GetGameTemplateBadRequest, *GetGameTemplateUnauthorized, *GetGameTemplateForbidden, *GetGameTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGameTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGameTemplate",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetGameTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetGameTemplateOK:
		return v, nil, nil, nil, nil, nil
	case *GetGameTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetGameTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetGameTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *GetGameTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetLocalizationTemplate gets a template localization

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [READ]</code> with scope <code>social</code>
			<br>Get a template localization
*/
func (a *Client) GetLocalizationTemplate(params *GetLocalizationTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocalizationTemplateOK, *GetLocalizationTemplateBadRequest, *GetLocalizationTemplateUnauthorized, *GetLocalizationTemplateForbidden, *GetLocalizationTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLocalizationTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLocalizationTemplate",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLocalizationTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetLocalizationTemplateOK:
		return v, nil, nil, nil, nil, nil
	case *GetLocalizationTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetLocalizationTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetLocalizationTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *GetLocalizationTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetNotificationTopicV1Admin gets topic information by topic name

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>get topic information by topic name.<br/>
			Action Code: 50215
*/
func (a *Client) GetNotificationTopicV1Admin(params *GetNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetNotificationTopicV1AdminOK, *GetNotificationTopicV1AdminUnauthorized, *GetNotificationTopicV1AdminForbidden, *GetNotificationTopicV1AdminNotFound, *GetNotificationTopicV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNotificationTopicV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getNotificationTopicV1Admin",
		Method:             "GET",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetNotificationTopicV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetNotificationTopicV1AdminOK:
		return v, nil, nil, nil, nil, nil
	case *GetNotificationTopicV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *GetNotificationTopicV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *GetNotificationTopicV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *GetNotificationTopicV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetNotifications gets all stored notification for a user

  Required permission : <code>NAMESPACE:{namespace}:USER:{userId}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>Retrieve all notification stored for a user. Successfully retrieved notifications will not be deleted.
*/
func (a *Client) GetNotifications(params *GetNotificationsParams, authInfo runtime.ClientAuthInfoWriter) (*GetNotificationsOK, *GetNotificationsBadRequest, *GetNotificationsUnauthorized, *GetNotificationsForbidden, *GetNotificationsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNotificationsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getNotifications",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/users/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetNotificationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetNotificationsOK:
		return v, nil, nil, nil, nil, nil
	case *GetNotificationsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetNotificationsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetNotificationsForbidden:
		return nil, nil, nil, v, nil, nil
	case *GetNotificationsNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetSingleTemplateLocalizationV1Admin gets a template localization

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>Get a template localization<br/>
			Action Code: 50207
*/
func (a *Client) GetSingleTemplateLocalizationV1Admin(params *GetSingleTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetSingleTemplateLocalizationV1AdminOK, *GetSingleTemplateLocalizationV1AdminUnauthorized, *GetSingleTemplateLocalizationV1AdminForbidden, *GetSingleTemplateLocalizationV1AdminNotFound, *GetSingleTemplateLocalizationV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSingleTemplateLocalizationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSingleTemplateLocalizationV1Admin",
		Method:             "GET",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSingleTemplateLocalizationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetSingleTemplateLocalizationV1AdminOK:
		return v, nil, nil, nil, nil, nil
	case *GetSingleTemplateLocalizationV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *GetSingleTemplateLocalizationV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *GetSingleTemplateLocalizationV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *GetSingleTemplateLocalizationV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetSlugTemplate gets all notification template in a slug

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [READ]</code> with scope <code>social</code>
			<br>Get all templates in a namespace
*/
func (a *Client) GetSlugTemplate(params *GetSlugTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*GetSlugTemplateOK, *GetSlugTemplateBadRequest, *GetSlugTemplateUnauthorized, *GetSlugTemplateForbidden, *GetSlugTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSlugTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSlugTemplate",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSlugTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetSlugTemplateOK:
		return v, nil, nil, nil, nil, nil
	case *GetSlugTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetSlugTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetSlugTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *GetSlugTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetTemplateSlugLocalizationsTemplateV1Admin gets all notification template localization in a slug

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [READ]</code> with scope <code>social</code>
			<br>Get all templates in a namespace<br>
			Action Code: 50205
*/
func (a *Client) GetTemplateSlugLocalizationsTemplateV1Admin(params *GetTemplateSlugLocalizationsTemplateV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*GetTemplateSlugLocalizationsTemplateV1AdminOK, *GetTemplateSlugLocalizationsTemplateV1AdminBadRequest, *GetTemplateSlugLocalizationsTemplateV1AdminUnauthorized, *GetTemplateSlugLocalizationsTemplateV1AdminForbidden, *GetTemplateSlugLocalizationsTemplateV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTemplateSlugLocalizationsTemplateV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTemplateSlugLocalizationsTemplateV1Admin",
		Method:             "GET",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTemplateSlugLocalizationsTemplateV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetTemplateSlugLocalizationsTemplateV1AdminOK:
		return v, nil, nil, nil, nil, nil
	case *GetTemplateSlugLocalizationsTemplateV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *GetTemplateSlugLocalizationsTemplateV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *GetTemplateSlugLocalizationsTemplateV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *GetTemplateSlugLocalizationsTemplateV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetTopicByNamespace gets topic by namespace

  Required permission : <code>NAMESPACE:{namespace}:TOPIC [READ]</code> with scope <code>social</code>
			<br>get topic by namespace.
*/
func (a *Client) GetTopicByNamespace(params *GetTopicByNamespaceParams, authInfo runtime.ClientAuthInfoWriter) (*GetTopicByNamespaceOK, *GetTopicByNamespaceUnauthorized, *GetTopicByNamespaceForbidden, *GetTopicByNamespaceNotFound, *GetTopicByNamespaceInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTopicByNamespaceParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTopicByNamespace",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTopicByNamespaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetTopicByNamespaceOK:
		return v, nil, nil, nil, nil, nil
	case *GetTopicByNamespaceUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *GetTopicByNamespaceForbidden:
		return nil, nil, v, nil, nil, nil
	case *GetTopicByNamespaceNotFound:
		return nil, nil, nil, v, nil, nil
	case *GetTopicByNamespaceInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetTopicByTopicName gets topic information by topic name

  Required permission : <code>NAMESPACE:{namespace}:TOPIC [READ]</code> with scope <code>social</code>
			<br>get topic information by topic name.
*/
func (a *Client) GetTopicByTopicName(params *GetTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetTopicByTopicNameOK, *GetTopicByTopicNameUnauthorized, *GetTopicByTopicNameForbidden, *GetTopicByTopicNameNotFound, *GetTopicByTopicNameInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTopicByTopicNameParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTopicByTopicName",
		Method:             "GET",
		PathPattern:        "/notification/namespaces/{namespace}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTopicByTopicNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetTopicByTopicNameOK:
		return v, nil, nil, nil, nil, nil
	case *GetTopicByTopicNameUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *GetTopicByTopicNameForbidden:
		return nil, nil, v, nil, nil, nil
	case *GetTopicByTopicNameNotFound:
		return nil, nil, nil, v, nil, nil
	case *GetTopicByTopicNameInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  NotificationWithTemplate sends notification to a user with template

  Required permission : <code>NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to all connected users in a namespace with predefined template.
			<br>In the request body, specify which template slug (template identifier) to use and the template language.
			<br>NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content.
			Template need to be published before it can be use to send notifications
*/
func (a *Client) NotificationWithTemplate(params *NotificationWithTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*NotificationWithTemplateAccepted, *NotificationWithTemplateBadRequest, *NotificationWithTemplateUnauthorized, *NotificationWithTemplateForbidden, *NotificationWithTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNotificationWithTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "notificationWithTemplate",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/templated",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NotificationWithTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *NotificationWithTemplateAccepted:
		return v, nil, nil, nil, nil, nil
	case *NotificationWithTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *NotificationWithTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *NotificationWithTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *NotificationWithTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  NotificationWithTemplateByUserID sends notification to a user with template

  Required permission : <code>NAMESPACE:{namespace}:USER:{userId}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to a user with predefined template. There are two types of notification: sync and async. Async message will be stored
			to database if the receiver is offline. This stored message could be retrieved later via websocket command.
			<br>In the request body, specify which template slug (template identifier) to use and the template language.
			<br>NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content.
			Template need to be published before it can be use to send notifications
*/
func (a *Client) NotificationWithTemplateByUserID(params *NotificationWithTemplateByUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*NotificationWithTemplateByUserIDNoContent, *NotificationWithTemplateByUserIDBadRequest, *NotificationWithTemplateByUserIDUnauthorized, *NotificationWithTemplateByUserIDForbidden, *NotificationWithTemplateByUserIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNotificationWithTemplateByUserIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "notificationWithTemplateByUserID",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/users/{userId}/templated",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NotificationWithTemplateByUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *NotificationWithTemplateByUserIDNoContent:
		return v, nil, nil, nil, nil, nil
	case *NotificationWithTemplateByUserIDBadRequest:
		return nil, v, nil, nil, nil, nil
	case *NotificationWithTemplateByUserIDUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *NotificationWithTemplateByUserIDForbidden:
		return nil, nil, nil, v, nil, nil
	case *NotificationWithTemplateByUserIDNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublishTemplate publishes draft template

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [CREATE]</code> with scope <code>social</code>
			<br>Publish notification template draft. Empty draft can not be published.
*/
func (a *Client) PublishTemplate(params *PublishTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*PublishTemplateNoContent, *PublishTemplateBadRequest, *PublishTemplateUnauthorized, *PublishTemplateForbidden, *PublishTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublishTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publishTemplate",
		Method:             "POST",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublishTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublishTemplateNoContent:
		return v, nil, nil, nil, nil, nil
	case *PublishTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *PublishTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *PublishTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *PublishTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublishTemplateLocalizationV1Admin publishes template localization draft

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Publish notification template draft. Empty draft can not be published.<br/>
			Action Code: 50210
*/
func (a *Client) PublishTemplateLocalizationV1Admin(params *PublishTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*PublishTemplateLocalizationV1AdminNoContent, *PublishTemplateLocalizationV1AdminUnauthorized, *PublishTemplateLocalizationV1AdminForbidden, *PublishTemplateLocalizationV1AdminNotFound, *PublishTemplateLocalizationV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublishTemplateLocalizationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publishTemplateLocalizationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublishTemplateLocalizationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublishTemplateLocalizationV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *PublishTemplateLocalizationV1AdminUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *PublishTemplateLocalizationV1AdminForbidden:
		return nil, nil, v, nil, nil, nil
	case *PublishTemplateLocalizationV1AdminNotFound:
		return nil, nil, nil, v, nil, nil
	case *PublishTemplateLocalizationV1AdminInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SendMultipleUsersFreeformNotificationV1Admin sends freeform notification to multiple users

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to multiple user. There are two types of notification: sync and async. Async message will be stored
			to database if the receiver is offline. This stored message could be retrieved later via websocket command.<br/>
			Action Code: 50211
*/
func (a *Client) SendMultipleUsersFreeformNotificationV1Admin(params *SendMultipleUsersFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendMultipleUsersFreeformNotificationV1AdminNoContent, *SendMultipleUsersFreeformNotificationV1AdminBadRequest, *SendMultipleUsersFreeformNotificationV1AdminUnauthorized, *SendMultipleUsersFreeformNotificationV1AdminForbidden, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendMultipleUsersFreeformNotificationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendMultipleUsersFreeformNotificationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/bulkUsers/freeform/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SendMultipleUsersFreeformNotificationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SendMultipleUsersFreeformNotificationV1AdminNoContent:
		return v, nil, nil, nil, nil
	case *SendMultipleUsersFreeformNotificationV1AdminBadRequest:
		return nil, v, nil, nil, nil
	case *SendMultipleUsersFreeformNotificationV1AdminUnauthorized:
		return nil, nil, v, nil, nil
	case *SendMultipleUsersFreeformNotificationV1AdminForbidden:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SendSpecificUserFreeformNotificationV1Admin sends freeform notification to a user

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to a user. There are two types of notification: sync and async. Async message will be stored
			to database if the receiver is offline. This stored message could be retrieved later via websocket command.<br/>
			Action Code: 50211
*/
func (a *Client) SendSpecificUserFreeformNotificationV1Admin(params *SendSpecificUserFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendSpecificUserFreeformNotificationV1AdminNoContent, *SendSpecificUserFreeformNotificationV1AdminBadRequest, *SendSpecificUserFreeformNotificationV1AdminUnauthorized, *SendSpecificUserFreeformNotificationV1AdminForbidden, *SendSpecificUserFreeformNotificationV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendSpecificUserFreeformNotificationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendSpecificUserFreeformNotificationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/freeform/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SendSpecificUserFreeformNotificationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SendSpecificUserFreeformNotificationV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *SendSpecificUserFreeformNotificationV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *SendSpecificUserFreeformNotificationV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *SendSpecificUserFreeformNotificationV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *SendSpecificUserFreeformNotificationV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SendSpecificUserTemplatedNotificationV1Admin sends templated notification to specific user

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends templated notification to a user. There are two types of notification: sync and async. Async message will be stored
			to database if the receiver is offline. This stored message could be retrieved later via websocket command.
			<br>In the request body, specify which template slug (template identifier) to use and the template language.
			<br>NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content.
			Template need to be published before it can be use to send notifications<br>
			Action Code: 50212
*/
func (a *Client) SendSpecificUserTemplatedNotificationV1Admin(params *SendSpecificUserTemplatedNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendSpecificUserTemplatedNotificationV1AdminNoContent, *SendSpecificUserTemplatedNotificationV1AdminBadRequest, *SendSpecificUserTemplatedNotificationV1AdminUnauthorized, *SendSpecificUserTemplatedNotificationV1AdminForbidden, *SendSpecificUserTemplatedNotificationV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendSpecificUserTemplatedNotificationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendSpecificUserTemplatedNotificationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/templates/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SendSpecificUserTemplatedNotificationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SendSpecificUserTemplatedNotificationV1AdminNoContent:
		return v, nil, nil, nil, nil, nil
	case *SendSpecificUserTemplatedNotificationV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *SendSpecificUserTemplatedNotificationV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *SendSpecificUserTemplatedNotificationV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *SendSpecificUserTemplatedNotificationV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SendUsersFreeformNotificationV1Admin sends freeform notification to connected users

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to all connected users in a namespace.<br>
			Action Code: 50201
*/
func (a *Client) SendUsersFreeformNotificationV1Admin(params *SendUsersFreeformNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendUsersFreeformNotificationV1AdminAccepted, *SendUsersFreeformNotificationV1AdminBadRequest, *SendUsersFreeformNotificationV1AdminUnauthorized, *SendUsersFreeformNotificationV1AdminForbidden, *SendUsersFreeformNotificationV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendUsersFreeformNotificationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendUsersFreeformNotificationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/freeform/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SendUsersFreeformNotificationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SendUsersFreeformNotificationV1AdminAccepted:
		return v, nil, nil, nil, nil, nil
	case *SendUsersFreeformNotificationV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *SendUsersFreeformNotificationV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *SendUsersFreeformNotificationV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *SendUsersFreeformNotificationV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SendUsersTemplatedNotificationV1Admin sends notification to a user with template

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [CREATE]</code> with scope <code>social</code>
			<br>Sends notification to all connected users in a namespace with predefined template.
			<br>In the request body, specify which template slug (template identifier) to use and the template language.
			<br>NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content.
			Template need to be published before it can be use to send notifications<br/>
			Action Code: 50202
*/
func (a *Client) SendUsersTemplatedNotificationV1Admin(params *SendUsersTemplatedNotificationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*SendUsersTemplatedNotificationV1AdminAccepted, *SendUsersTemplatedNotificationV1AdminBadRequest, *SendUsersTemplatedNotificationV1AdminUnauthorized, *SendUsersTemplatedNotificationV1AdminForbidden, *SendUsersTemplatedNotificationV1AdminNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendUsersTemplatedNotificationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendUsersTemplatedNotificationV1Admin",
		Method:             "POST",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SendUsersTemplatedNotificationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SendUsersTemplatedNotificationV1AdminAccepted:
		return v, nil, nil, nil, nil, nil
	case *SendUsersTemplatedNotificationV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil
	case *SendUsersTemplatedNotificationV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *SendUsersTemplatedNotificationV1AdminForbidden:
		return nil, nil, nil, v, nil, nil
	case *SendUsersTemplatedNotificationV1AdminNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateLocalizationTemplate updates template draft

  Required permission : <code>NAMESPACE:{namespace}:TEMPLATE [UPDATE]</code> with scope <code>social</code>
			<br>Modify draft template
*/
func (a *Client) UpdateLocalizationTemplate(params *UpdateLocalizationTemplateParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateLocalizationTemplateNoContent, *UpdateLocalizationTemplateBadRequest, *UpdateLocalizationTemplateUnauthorized, *UpdateLocalizationTemplateForbidden, *UpdateLocalizationTemplateNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLocalizationTemplateParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateLocalizationTemplate",
		Method:             "PUT",
		PathPattern:        "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateLocalizationTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateLocalizationTemplateNoContent:
		return v, nil, nil, nil, nil, nil
	case *UpdateLocalizationTemplateBadRequest:
		return nil, v, nil, nil, nil, nil
	case *UpdateLocalizationTemplateUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *UpdateLocalizationTemplateForbidden:
		return nil, nil, nil, v, nil, nil
	case *UpdateLocalizationTemplateNotFound:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateNotificationTopicV1Admin updates topic information by topic name

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [UPDATE]</code> with scope <code>social</code>
			<br>update topic information by topic name.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created <br/>
			Action Code: 50216
*/
func (a *Client) UpdateNotificationTopicV1Admin(params *UpdateNotificationTopicV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateNotificationTopicV1AdminNoContent, *UpdateNotificationTopicV1AdminBadRequest, *UpdateNotificationTopicV1AdminUnauthorized, *UpdateNotificationTopicV1AdminForbidden, *UpdateNotificationTopicV1AdminNotFound, *UpdateNotificationTopicV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateNotificationTopicV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateNotificationTopicV1Admin",
		Method:             "PUT",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateNotificationTopicV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateNotificationTopicV1AdminNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *UpdateNotificationTopicV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *UpdateNotificationTopicV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *UpdateNotificationTopicV1AdminForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *UpdateNotificationTopicV1AdminNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *UpdateNotificationTopicV1AdminInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateTemplateLocalizationV1Admin updates template localization

  Required permission : <code>ADMIN:NAMESPACE:{namespace}:NOTIFICATION [UPDATE]</code> with scope <code>social</code>
			<br/>update template localization<br/>
			Action Code: 50208
*/
func (a *Client) UpdateTemplateLocalizationV1Admin(params *UpdateTemplateLocalizationV1AdminParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateTemplateLocalizationV1AdminNoContent, *UpdateTemplateLocalizationV1AdminBadRequest, *UpdateTemplateLocalizationV1AdminUnauthorized, *UpdateTemplateLocalizationV1AdminForbidden, *UpdateTemplateLocalizationV1AdminNotFound, *UpdateTemplateLocalizationV1AdminInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateTemplateLocalizationV1AdminParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateTemplateLocalizationV1Admin",
		Method:             "PUT",
		PathPattern:        "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateTemplateLocalizationV1AdminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateTemplateLocalizationV1AdminNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *UpdateTemplateLocalizationV1AdminBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *UpdateTemplateLocalizationV1AdminUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *UpdateTemplateLocalizationV1AdminForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *UpdateTemplateLocalizationV1AdminNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *UpdateTemplateLocalizationV1AdminInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateTopicByTopicName updates topic information by topic name

  Required permission : <code>NAMESPACE:{namespace}:TOPIC [UPDATE]</code> with scope <code>social</code>
			<br>update topic information by topic name.
			<br>topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST.
			Already existing topic can not be created
*/
func (a *Client) UpdateTopicByTopicName(params *UpdateTopicByTopicNameParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateTopicByTopicNameNoContent, *UpdateTopicByTopicNameUnauthorized, *UpdateTopicByTopicNameForbidden, *UpdateTopicByTopicNameNotFound, *UpdateTopicByTopicNameInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateTopicByTopicNameParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateTopicByTopicName",
		Method:             "PUT",
		PathPattern:        "/notification/namespaces/{namespace}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateTopicByTopicNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateTopicByTopicNameNoContent:
		return v, nil, nil, nil, nil, nil
	case *UpdateTopicByTopicNameUnauthorized:
		return nil, v, nil, nil, nil, nil
	case *UpdateTopicByTopicNameForbidden:
		return nil, nil, v, nil, nil, nil
	case *UpdateTopicByTopicNameNotFound:
		return nil, nil, nil, v, nil, nil
	case *UpdateTopicByTopicNameInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
