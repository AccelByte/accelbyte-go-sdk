// Copyright (c) 2021 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// Code generated by go-swagger; DO NOT EDIT.

package game_session

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new game session API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for game session API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AdminQueryGameSessions(params *AdminQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminQueryGameSessionsOK, *AdminQueryGameSessionsBadRequest, *AdminQueryGameSessionsUnauthorized, *AdminQueryGameSessionsForbidden, *AdminQueryGameSessionsInternalServerError, error)
	AdminQueryGameSessionsShort(params *AdminQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminQueryGameSessionsOK, error)
	AdminUpdateGameSessionMember(params *AdminUpdateGameSessionMemberParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateGameSessionMemberOK, *AdminUpdateGameSessionMemberBadRequest, *AdminUpdateGameSessionMemberUnauthorized, *AdminUpdateGameSessionMemberForbidden, *AdminUpdateGameSessionMemberNotFound, *AdminUpdateGameSessionMemberInternalServerError, error)
	AdminUpdateGameSessionMemberShort(params *AdminUpdateGameSessionMemberParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateGameSessionMemberOK, error)
	CreateGameSession(params *CreateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*CreateGameSessionCreated, *CreateGameSessionBadRequest, *CreateGameSessionUnauthorized, *CreateGameSessionForbidden, *CreateGameSessionInternalServerError, error)
	CreateGameSessionShort(params *CreateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*CreateGameSessionCreated, error)
	DeleteGameSession(params *DeleteGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteGameSessionNoContent, *DeleteGameSessionUnauthorized, *DeleteGameSessionForbidden, *DeleteGameSessionInternalServerError, error)
	DeleteGameSessionShort(params *DeleteGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteGameSessionNoContent, error)
	GetGameSession(params *GetGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionOK, *GetGameSessionBadRequest, *GetGameSessionUnauthorized, *GetGameSessionForbidden, *GetGameSessionNotFound, *GetGameSessionInternalServerError, error)
	GetGameSessionShort(params *GetGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionOK, error)
	GetGameSessionByPodName(params *GetGameSessionByPodNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionByPodNameOK, *GetGameSessionByPodNameBadRequest, *GetGameSessionByPodNameUnauthorized, *GetGameSessionByPodNameForbidden, *GetGameSessionByPodNameNotFound, *GetGameSessionByPodNameInternalServerError, error)
	GetGameSessionByPodNameShort(params *GetGameSessionByPodNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionByPodNameOK, error)
	JoinGameSession(params *JoinGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*JoinGameSessionOK, *JoinGameSessionBadRequest, *JoinGameSessionUnauthorized, *JoinGameSessionForbidden, *JoinGameSessionNotFound, *JoinGameSessionInternalServerError, error)
	JoinGameSessionShort(params *JoinGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*JoinGameSessionOK, error)
	LeaveGameSession(params *LeaveGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*LeaveGameSessionNoContent, *LeaveGameSessionBadRequest, *LeaveGameSessionUnauthorized, *LeaveGameSessionForbidden, *LeaveGameSessionNotFound, *LeaveGameSessionInternalServerError, error)
	LeaveGameSessionShort(params *LeaveGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*LeaveGameSessionNoContent, error)
	PatchUpdateGameSession(params *PatchUpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*PatchUpdateGameSessionOK, *PatchUpdateGameSessionBadRequest, *PatchUpdateGameSessionUnauthorized, *PatchUpdateGameSessionForbidden, *PatchUpdateGameSessionNotFound, *PatchUpdateGameSessionInternalServerError, error)
	PatchUpdateGameSessionShort(params *PatchUpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*PatchUpdateGameSessionOK, error)
	PublicGameSessionInvite(params *PublicGameSessionInviteParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionInviteCreated, *PublicGameSessionInviteNoContent, *PublicGameSessionInviteBadRequest, *PublicGameSessionInviteUnauthorized, *PublicGameSessionInviteNotFound, *PublicGameSessionInviteInternalServerError, error)
	PublicGameSessionInviteShort(params *PublicGameSessionInviteParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionInviteCreated, error)
	PublicGameSessionReject(params *PublicGameSessionRejectParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionRejectNoContent, *PublicGameSessionRejectBadRequest, *PublicGameSessionRejectUnauthorized, *PublicGameSessionRejectForbidden, *PublicGameSessionRejectNotFound, *PublicGameSessionRejectInternalServerError, error)
	PublicGameSessionRejectShort(params *PublicGameSessionRejectParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionRejectNoContent, error)
	PublicQueryGameSessions(params *PublicQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryGameSessionsOK, *PublicQueryGameSessionsBadRequest, *PublicQueryGameSessionsUnauthorized, *PublicQueryGameSessionsForbidden, *PublicQueryGameSessionsInternalServerError, error)
	PublicQueryGameSessionsShort(params *PublicQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryGameSessionsOK, error)
	PublicQueryMyGameSessions(params *PublicQueryMyGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryMyGameSessionsOK, *PublicQueryMyGameSessionsBadRequest, *PublicQueryMyGameSessionsUnauthorized, *PublicQueryMyGameSessionsInternalServerError, error)
	PublicQueryMyGameSessionsShort(params *PublicQueryMyGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryMyGameSessionsOK, error)
	UpdateGameSession(params *UpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionOK, *UpdateGameSessionBadRequest, *UpdateGameSessionUnauthorized, *UpdateGameSessionForbidden, *UpdateGameSessionNotFound, *UpdateGameSessionInternalServerError, error)
	UpdateGameSessionShort(params *UpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionOK, error)
	UpdateGameSessionBackfillTicketID(params *UpdateGameSessionBackfillTicketIDParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionBackfillTicketIDOK, *UpdateGameSessionBackfillTicketIDUnauthorized, *UpdateGameSessionBackfillTicketIDForbidden, *UpdateGameSessionBackfillTicketIDNotFound, *UpdateGameSessionBackfillTicketIDInternalServerError, error)
	UpdateGameSessionBackfillTicketIDShort(params *UpdateGameSessionBackfillTicketIDParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionBackfillTicketIDOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
Deprecated: Use AdminQueryGameSessionsShort instead.

  AdminQueryGameSessions gets all game sessions

  Get all game sessions. Requires ADMIN:NAMESPACE:{namespace}:SESSION:GAME [READ]
*/
func (a *Client) AdminQueryGameSessions(params *AdminQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminQueryGameSessionsOK, *AdminQueryGameSessionsBadRequest, *AdminQueryGameSessionsUnauthorized, *AdminQueryGameSessionsForbidden, *AdminQueryGameSessionsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminQueryGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "adminQueryGameSessions",
		Method:             "GET",
		PathPattern:        "/session/v1/admin/namespaces/{namespace}/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminQueryGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminQueryGameSessionsOK:
		return v, nil, nil, nil, nil, nil

	case *AdminQueryGameSessionsBadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminQueryGameSessionsUnauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminQueryGameSessionsForbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminQueryGameSessionsInternalServerError:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminQueryGameSessionsShort gets all game sessions

  Get all game sessions. Requires ADMIN:NAMESPACE:{namespace}:SESSION:GAME [READ]
*/
func (a *Client) AdminQueryGameSessionsShort(params *AdminQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminQueryGameSessionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminQueryGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "adminQueryGameSessions",
		Method:             "GET",
		PathPattern:        "/session/v1/admin/namespaces/{namespace}/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminQueryGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminQueryGameSessionsOK:
		return v, nil
	case *AdminQueryGameSessionsBadRequest:
		return nil, v
	case *AdminQueryGameSessionsUnauthorized:
		return nil, v
	case *AdminQueryGameSessionsForbidden:
		return nil, v
	case *AdminQueryGameSessionsInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminUpdateGameSessionMemberShort instead.

  AdminUpdateGameSessionMember updates status of a game session member requires a d m i n n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update a game session member status.
*/
func (a *Client) AdminUpdateGameSessionMember(params *AdminUpdateGameSessionMemberParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateGameSessionMemberOK, *AdminUpdateGameSessionMemberBadRequest, *AdminUpdateGameSessionMemberUnauthorized, *AdminUpdateGameSessionMemberForbidden, *AdminUpdateGameSessionMemberNotFound, *AdminUpdateGameSessionMemberInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateGameSessionMemberParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "adminUpdateGameSessionMember",
		Method:             "PUT",
		PathPattern:        "/session/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}/members/{memberId}/status/{statusType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateGameSessionMemberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateGameSessionMemberOK:
		return v, nil, nil, nil, nil, nil, nil

	case *AdminUpdateGameSessionMemberBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *AdminUpdateGameSessionMemberUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *AdminUpdateGameSessionMemberForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *AdminUpdateGameSessionMemberNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *AdminUpdateGameSessionMemberInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateGameSessionMemberShort updates status of a game session member requires a d m i n n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update a game session member status.
*/
func (a *Client) AdminUpdateGameSessionMemberShort(params *AdminUpdateGameSessionMemberParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateGameSessionMemberOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateGameSessionMemberParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "adminUpdateGameSessionMember",
		Method:             "PUT",
		PathPattern:        "/session/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}/members/{memberId}/status/{statusType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateGameSessionMemberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateGameSessionMemberOK:
		return v, nil
	case *AdminUpdateGameSessionMemberBadRequest:
		return nil, v
	case *AdminUpdateGameSessionMemberUnauthorized:
		return nil, v
	case *AdminUpdateGameSessionMemberForbidden:
		return nil, v
	case *AdminUpdateGameSessionMemberNotFound:
		return nil, v
	case *AdminUpdateGameSessionMemberInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use CreateGameSessionShort instead.

  CreateGameSession creates a game session requires n a m e s p a c e namespace s e s s i o n g a m e c r e a t e

  Create a game session.
      Session configuration name is mandatory, this API will refer following values from the session template if they&#39;re not provided in the request:
   - type
   - joinability
   - minPlayers
   - maxPlayers
   - inviteTimeout
   - inactiveTimeout

      When the session type is a DS, a DS creation request will be sent to DSMC if number of active players reaches session&#39;s minPlayers.

Active user is a user who present within the session, has status CONNECTED/JOINED.

      Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) CreateGameSession(params *CreateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*CreateGameSessionCreated, *CreateGameSessionBadRequest, *CreateGameSessionUnauthorized, *CreateGameSessionForbidden, *CreateGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createGameSession",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesession",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateGameSessionCreated:
		return v, nil, nil, nil, nil, nil

	case *CreateGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil

	case *CreateGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil

	case *CreateGameSessionForbidden:
		return nil, nil, nil, v, nil, nil

	case *CreateGameSessionInternalServerError:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateGameSessionShort creates a game session requires n a m e s p a c e namespace s e s s i o n g a m e c r e a t e

  Create a game session.
      Session configuration name is mandatory, this API will refer following values from the session template if they&#39;re not provided in the request:
   - type
   - joinability
   - minPlayers
   - maxPlayers
   - inviteTimeout
   - inactiveTimeout

      When the session type is a DS, a DS creation request will be sent to DSMC if number of active players reaches session&#39;s minPlayers.

Active user is a user who present within the session, has status CONNECTED/JOINED.

      Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) CreateGameSessionShort(params *CreateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*CreateGameSessionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createGameSession",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesession",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *CreateGameSessionCreated:
		return v, nil
	case *CreateGameSessionBadRequest:
		return nil, v
	case *CreateGameSessionUnauthorized:
		return nil, v
	case *CreateGameSessionForbidden:
		return nil, v
	case *CreateGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use DeleteGameSessionShort instead.

  DeleteGameSession deletes a game session requires n a m e s p a c e namespace s e s s i o n g a m e d e l e t e

  Delete a game session.
*/
func (a *Client) DeleteGameSession(params *DeleteGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteGameSessionNoContent, *DeleteGameSessionUnauthorized, *DeleteGameSessionForbidden, *DeleteGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteGameSession",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteGameSessionNoContent:
		return v, nil, nil, nil, nil

	case *DeleteGameSessionUnauthorized:
		return nil, v, nil, nil, nil

	case *DeleteGameSessionForbidden:
		return nil, nil, v, nil, nil

	case *DeleteGameSessionInternalServerError:
		return nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteGameSessionShort deletes a game session requires n a m e s p a c e namespace s e s s i o n g a m e d e l e t e

  Delete a game session.
*/
func (a *Client) DeleteGameSessionShort(params *DeleteGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteGameSessionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteGameSession",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *DeleteGameSessionNoContent:
		return v, nil
	case *DeleteGameSessionUnauthorized:
		return nil, v
	case *DeleteGameSessionForbidden:
		return nil, v
	case *DeleteGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use GetGameSessionShort instead.

  GetGameSession gets game session detail requires n a m e s p a c e namespace s e s s i o n g a m e r e a d

  Get game session detail.
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) GetGameSession(params *GetGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionOK, *GetGameSessionBadRequest, *GetGameSessionUnauthorized, *GetGameSessionForbidden, *GetGameSessionNotFound, *GetGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGameSession",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetGameSessionOK:
		return v, nil, nil, nil, nil, nil, nil

	case *GetGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *GetGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *GetGameSessionForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *GetGameSessionNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *GetGameSessionInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetGameSessionShort gets game session detail requires n a m e s p a c e namespace s e s s i o n g a m e r e a d

  Get game session detail.
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) GetGameSessionShort(params *GetGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGameSession",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetGameSessionOK:
		return v, nil
	case *GetGameSessionBadRequest:
		return nil, v
	case *GetGameSessionUnauthorized:
		return nil, v
	case *GetGameSessionForbidden:
		return nil, v
	case *GetGameSessionNotFound:
		return nil, v
	case *GetGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use GetGameSessionByPodNameShort instead.

  GetGameSessionByPodName gets game session detail requires n a m e s p a c e namespace s e s s i o n g a m e r e a d

  Get game session detail by podname.
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) GetGameSessionByPodName(params *GetGameSessionByPodNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionByPodNameOK, *GetGameSessionByPodNameBadRequest, *GetGameSessionByPodNameUnauthorized, *GetGameSessionByPodNameForbidden, *GetGameSessionByPodNameNotFound, *GetGameSessionByPodNameInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGameSessionByPodNameParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGameSessionByPodName",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/servers/{podName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGameSessionByPodNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetGameSessionByPodNameOK:
		return v, nil, nil, nil, nil, nil, nil

	case *GetGameSessionByPodNameBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *GetGameSessionByPodNameUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *GetGameSessionByPodNameForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *GetGameSessionByPodNameNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *GetGameSessionByPodNameInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetGameSessionByPodNameShort gets game session detail requires n a m e s p a c e namespace s e s s i o n g a m e r e a d

  Get game session detail by podname.
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) GetGameSessionByPodNameShort(params *GetGameSessionByPodNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetGameSessionByPodNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGameSessionByPodNameParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGameSessionByPodName",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/servers/{podName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGameSessionByPodNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetGameSessionByPodNameOK:
		return v, nil
	case *GetGameSessionByPodNameBadRequest:
		return nil, v
	case *GetGameSessionByPodNameUnauthorized:
		return nil, v
	case *GetGameSessionByPodNameForbidden:
		return nil, v
	case *GetGameSessionByPodNameNotFound:
		return nil, v
	case *GetGameSessionByPodNameInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use JoinGameSessionShort instead.

  JoinGameSession joins a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r c r e a t e

  Join a game session.
*/
func (a *Client) JoinGameSession(params *JoinGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*JoinGameSessionOK, *JoinGameSessionBadRequest, *JoinGameSessionUnauthorized, *JoinGameSessionForbidden, *JoinGameSessionNotFound, *JoinGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJoinGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "joinGameSession",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/join",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &JoinGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *JoinGameSessionOK:
		return v, nil, nil, nil, nil, nil, nil

	case *JoinGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *JoinGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *JoinGameSessionForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *JoinGameSessionNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *JoinGameSessionInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  JoinGameSessionShort joins a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r c r e a t e

  Join a game session.
*/
func (a *Client) JoinGameSessionShort(params *JoinGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*JoinGameSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJoinGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "joinGameSession",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/join",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &JoinGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *JoinGameSessionOK:
		return v, nil
	case *JoinGameSessionBadRequest:
		return nil, v
	case *JoinGameSessionUnauthorized:
		return nil, v
	case *JoinGameSessionForbidden:
		return nil, v
	case *JoinGameSessionNotFound:
		return nil, v
	case *JoinGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use LeaveGameSessionShort instead.

  LeaveGameSession leaves a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r d e l e t e

  Leave a game session.
*/
func (a *Client) LeaveGameSession(params *LeaveGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*LeaveGameSessionNoContent, *LeaveGameSessionBadRequest, *LeaveGameSessionUnauthorized, *LeaveGameSessionForbidden, *LeaveGameSessionNotFound, *LeaveGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLeaveGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "leaveGameSession",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/leave",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LeaveGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *LeaveGameSessionNoContent:
		return v, nil, nil, nil, nil, nil, nil

	case *LeaveGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *LeaveGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *LeaveGameSessionForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *LeaveGameSessionNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *LeaveGameSessionInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  LeaveGameSessionShort leaves a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r d e l e t e

  Leave a game session.
*/
func (a *Client) LeaveGameSessionShort(params *LeaveGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*LeaveGameSessionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLeaveGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "leaveGameSession",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/leave",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LeaveGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *LeaveGameSessionNoContent:
		return v, nil
	case *LeaveGameSessionBadRequest:
		return nil, v
	case *LeaveGameSessionUnauthorized:
		return nil, v
	case *LeaveGameSessionForbidden:
		return nil, v
	case *LeaveGameSessionNotFound:
		return nil, v
	case *LeaveGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use PatchUpdateGameSessionShort instead.

  PatchUpdateGameSession patches update a game session requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update specified fields from game session data.
*/
func (a *Client) PatchUpdateGameSession(params *PatchUpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*PatchUpdateGameSessionOK, *PatchUpdateGameSessionBadRequest, *PatchUpdateGameSessionUnauthorized, *PatchUpdateGameSessionForbidden, *PatchUpdateGameSessionNotFound, *PatchUpdateGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchUpdateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchUpdateGameSession",
		Method:             "PATCH",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchUpdateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PatchUpdateGameSessionOK:
		return v, nil, nil, nil, nil, nil, nil

	case *PatchUpdateGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *PatchUpdateGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *PatchUpdateGameSessionForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *PatchUpdateGameSessionNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *PatchUpdateGameSessionInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PatchUpdateGameSessionShort patches update a game session requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update specified fields from game session data.
*/
func (a *Client) PatchUpdateGameSessionShort(params *PatchUpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*PatchUpdateGameSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchUpdateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchUpdateGameSession",
		Method:             "PATCH",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchUpdateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PatchUpdateGameSessionOK:
		return v, nil
	case *PatchUpdateGameSessionBadRequest:
		return nil, v
	case *PatchUpdateGameSessionUnauthorized:
		return nil, v
	case *PatchUpdateGameSessionForbidden:
		return nil, v
	case *PatchUpdateGameSessionNotFound:
		return nil, v
	case *PatchUpdateGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use PublicGameSessionInviteShort instead.

  PublicGameSessionInvite invites a user to a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r c r e a t e

  Invite a user to a game session.
*/
func (a *Client) PublicGameSessionInvite(params *PublicGameSessionInviteParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionInviteCreated, *PublicGameSessionInviteNoContent, *PublicGameSessionInviteBadRequest, *PublicGameSessionInviteUnauthorized, *PublicGameSessionInviteNotFound, *PublicGameSessionInviteInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGameSessionInviteParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGameSessionInvite",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/invite",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicGameSessionInviteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGameSessionInviteCreated:
		return v, nil, nil, nil, nil, nil, nil

	case *PublicGameSessionInviteNoContent:
		return nil, v, nil, nil, nil, nil, nil

	case *PublicGameSessionInviteBadRequest:
		return nil, nil, v, nil, nil, nil, nil

	case *PublicGameSessionInviteUnauthorized:
		return nil, nil, nil, v, nil, nil, nil

	case *PublicGameSessionInviteNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *PublicGameSessionInviteInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGameSessionInviteShort invites a user to a game session requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r c r e a t e

  Invite a user to a game session.
*/
func (a *Client) PublicGameSessionInviteShort(params *PublicGameSessionInviteParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionInviteCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGameSessionInviteParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGameSessionInvite",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/invite",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicGameSessionInviteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGameSessionInviteCreated:
		return v, nil
	case *PublicGameSessionInviteNoContent:
		return nil, v
	case *PublicGameSessionInviteBadRequest:
		return nil, v
	case *PublicGameSessionInviteUnauthorized:
		return nil, v
	case *PublicGameSessionInviteNotFound:
		return nil, v
	case *PublicGameSessionInviteInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use PublicGameSessionRejectShort instead.

  PublicGameSessionReject rejects a game session invitation requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r d e l e t e

  Reject a game session invitation.
*/
func (a *Client) PublicGameSessionReject(params *PublicGameSessionRejectParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionRejectNoContent, *PublicGameSessionRejectBadRequest, *PublicGameSessionRejectUnauthorized, *PublicGameSessionRejectForbidden, *PublicGameSessionRejectNotFound, *PublicGameSessionRejectInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGameSessionRejectParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGameSessionReject",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/reject",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicGameSessionRejectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGameSessionRejectNoContent:
		return v, nil, nil, nil, nil, nil, nil

	case *PublicGameSessionRejectBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *PublicGameSessionRejectUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *PublicGameSessionRejectForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *PublicGameSessionRejectNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *PublicGameSessionRejectInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGameSessionRejectShort rejects a game session invitation requires n a m e s p a c e namespace s e s s i o n g a m e p l a y e r d e l e t e

  Reject a game session invitation.
*/
func (a *Client) PublicGameSessionRejectShort(params *PublicGameSessionRejectParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGameSessionRejectNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGameSessionRejectParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGameSessionReject",
		Method:             "DELETE",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/reject",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicGameSessionRejectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGameSessionRejectNoContent:
		return v, nil
	case *PublicGameSessionRejectBadRequest:
		return nil, v
	case *PublicGameSessionRejectUnauthorized:
		return nil, v
	case *PublicGameSessionRejectForbidden:
		return nil, v
	case *PublicGameSessionRejectNotFound:
		return nil, v
	case *PublicGameSessionRejectInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use PublicQueryGameSessionsShort instead.

  PublicQueryGameSessions queries game sessions

  Query game sessions.

By default, API will return a list of available game sessions (joinability: open).
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) PublicQueryGameSessions(params *PublicQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryGameSessionsOK, *PublicQueryGameSessionsBadRequest, *PublicQueryGameSessionsUnauthorized, *PublicQueryGameSessionsForbidden, *PublicQueryGameSessionsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryGameSessions",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicQueryGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicQueryGameSessionsOK:
		return v, nil, nil, nil, nil, nil

	case *PublicQueryGameSessionsBadRequest:
		return nil, v, nil, nil, nil, nil

	case *PublicQueryGameSessionsUnauthorized:
		return nil, nil, v, nil, nil, nil

	case *PublicQueryGameSessionsForbidden:
		return nil, nil, nil, v, nil, nil

	case *PublicQueryGameSessionsInternalServerError:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicQueryGameSessionsShort queries game sessions

  Query game sessions.

By default, API will return a list of available game sessions (joinability: open).
Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) PublicQueryGameSessionsShort(params *PublicQueryGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryGameSessionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryGameSessions",
		Method:             "POST",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicQueryGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicQueryGameSessionsOK:
		return v, nil
	case *PublicQueryGameSessionsBadRequest:
		return nil, v
	case *PublicQueryGameSessionsUnauthorized:
		return nil, v
	case *PublicQueryGameSessionsForbidden:
		return nil, v
	case *PublicQueryGameSessionsInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use PublicQueryMyGameSessionsShort instead.

  PublicQueryMyGameSessions queries user s game sessions

  Query user&#39;s game sessions.
By default, API will return a list of user&#39;s active game sessions (INVITED,JOINED,CONNECTED).

Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) PublicQueryMyGameSessions(params *PublicQueryMyGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryMyGameSessionsOK, *PublicQueryMyGameSessionsBadRequest, *PublicQueryMyGameSessionsUnauthorized, *PublicQueryMyGameSessionsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryMyGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryMyGameSessions",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/users/me/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicQueryMyGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicQueryMyGameSessionsOK:
		return v, nil, nil, nil, nil

	case *PublicQueryMyGameSessionsBadRequest:
		return nil, v, nil, nil, nil

	case *PublicQueryMyGameSessionsUnauthorized:
		return nil, nil, v, nil, nil

	case *PublicQueryMyGameSessionsInternalServerError:
		return nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicQueryMyGameSessionsShort queries user s game sessions

  Query user&#39;s game sessions.
By default, API will return a list of user&#39;s active game sessions (INVITED,JOINED,CONNECTED).

Session service has several DSInformation status to track DS request to DSMC:
   - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested.
   - REQUESTED: DS is being requested to DSMC.
   - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY.
   - FAILED_TO_REQUEST: DSMC fails to create the DS.

*/
func (a *Client) PublicQueryMyGameSessionsShort(params *PublicQueryMyGameSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryMyGameSessionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryMyGameSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryMyGameSessions",
		Method:             "GET",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/users/me/gamesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicQueryMyGameSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicQueryMyGameSessionsOK:
		return v, nil
	case *PublicQueryMyGameSessionsBadRequest:
		return nil, v
	case *PublicQueryMyGameSessionsUnauthorized:
		return nil, v
	case *PublicQueryMyGameSessionsInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use UpdateGameSessionShort instead.

  UpdateGameSession updates a game session requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Updates a game session, this endpoint will override stored gamesession data.
      To update only specified fields, please use following endpoint:
  method : PATCH
  API	 : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}

To update DS attributes (clientVersion, deployment, requestedRegions) it will only be applied only as long as no DS has been requested, otherwise ignored.

*/
func (a *Client) UpdateGameSession(params *UpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionOK, *UpdateGameSessionBadRequest, *UpdateGameSessionUnauthorized, *UpdateGameSessionForbidden, *UpdateGameSessionNotFound, *UpdateGameSessionInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateGameSession",
		Method:             "PUT",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateGameSessionOK:
		return v, nil, nil, nil, nil, nil, nil

	case *UpdateGameSessionBadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *UpdateGameSessionUnauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *UpdateGameSessionForbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *UpdateGameSessionNotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *UpdateGameSessionInternalServerError:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateGameSessionShort updates a game session requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Updates a game session, this endpoint will override stored gamesession data.
      To update only specified fields, please use following endpoint:
  method : PATCH
  API	 : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}

To update DS attributes (clientVersion, deployment, requestedRegions) it will only be applied only as long as no DS has been requested, otherwise ignored.

*/
func (a *Client) UpdateGameSessionShort(params *UpdateGameSessionParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGameSessionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateGameSession",
		Method:             "PUT",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGameSessionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *UpdateGameSessionOK:
		return v, nil
	case *UpdateGameSessionBadRequest:
		return nil, v
	case *UpdateGameSessionUnauthorized:
		return nil, v
	case *UpdateGameSessionForbidden:
		return nil, v
	case *UpdateGameSessionNotFound:
		return nil, v
	case *UpdateGameSessionInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use UpdateGameSessionBackfillTicketIDShort instead.

  UpdateGameSessionBackfillTicketID updates game session backfill ticket id requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update game session backfill ticket id. Will override game session backfill ticket based on given request parameter
*/
func (a *Client) UpdateGameSessionBackfillTicketID(params *UpdateGameSessionBackfillTicketIDParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionBackfillTicketIDOK, *UpdateGameSessionBackfillTicketIDUnauthorized, *UpdateGameSessionBackfillTicketIDForbidden, *UpdateGameSessionBackfillTicketIDNotFound, *UpdateGameSessionBackfillTicketIDInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGameSessionBackfillTicketIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateGameSessionBackfillTicketID",
		Method:             "PUT",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/backfill",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGameSessionBackfillTicketIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateGameSessionBackfillTicketIDOK:
		return v, nil, nil, nil, nil, nil

	case *UpdateGameSessionBackfillTicketIDUnauthorized:
		return nil, v, nil, nil, nil, nil

	case *UpdateGameSessionBackfillTicketIDForbidden:
		return nil, nil, v, nil, nil, nil

	case *UpdateGameSessionBackfillTicketIDNotFound:
		return nil, nil, nil, v, nil, nil

	case *UpdateGameSessionBackfillTicketIDInternalServerError:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateGameSessionBackfillTicketIDShort updates game session backfill ticket id requires n a m e s p a c e namespace s e s s i o n g a m e u p d a t e

  Update game session backfill ticket id. Will override game session backfill ticket based on given request parameter
*/
func (a *Client) UpdateGameSessionBackfillTicketIDShort(params *UpdateGameSessionBackfillTicketIDParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateGameSessionBackfillTicketIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGameSessionBackfillTicketIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateGameSessionBackfillTicketID",
		Method:             "PUT",
		PathPattern:        "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/backfill",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGameSessionBackfillTicketIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *UpdateGameSessionBackfillTicketIDOK:
		return v, nil
	case *UpdateGameSessionBackfillTicketIDUnauthorized:
		return nil, v
	case *UpdateGameSessionBackfillTicketIDForbidden:
		return nil, v
	case *UpdateGameSessionBackfillTicketIDNotFound:
		return nil, v
	case *UpdateGameSessionBackfillTicketIDInternalServerError:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
