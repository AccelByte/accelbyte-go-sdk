// Code generated by go-swagger; DO NOT EDIT.

package config

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new config API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for config API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreateImage(params *CreateImageParams, authInfo runtime.ClientAuthInfoWriter) (*CreateImageNoContent, error)

	DeleteImage(params *DeleteImageParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteImageNoContent, error)

	ExportImages(params *ExportImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ExportImagesOK, error)

	GetConfig(params *GetConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetConfigOK, error)

	GetImageDetail(params *GetImageDetailParams, authInfo runtime.ClientAuthInfoWriter) (*GetImageDetailOK, error)

	GetImageLimit(params *GetImageLimitParams, authInfo runtime.ClientAuthInfoWriter) (*GetImageLimitOK, error)

	ImportImages(params *ImportImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ImportImagesOK, error)

	ListConfig(params *ListConfigParams, authInfo runtime.ClientAuthInfoWriter) (*ListConfigOK, error)

	ListImages(params *ListImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ListImagesOK, error)

	SaveConfig(params *SaveConfigParams, authInfo runtime.ClientAuthInfoWriter) (*SaveConfigNoContent, error)

	UpdateConfig(params *UpdateConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateConfigNoContent, error)

	UpdateDeployment(params *UpdateDeploymentParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateDeploymentNoContent, error)

	UpdateImage(params *UpdateImageParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateImageNoContent, error)

	ExportConfigV1(params *ExportConfigV1Params, authInfo runtime.ClientAuthInfoWriter) (*ExportConfigV1OK, error)

	ImportConfigV1(params *ImportConfigV1Params, authInfo runtime.ClientAuthInfoWriter) (*ImportConfigV1OK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreateImage creates image

  ```
Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [CREATE]
Required scope: social

This endpoint will create image.

Sample image:
{
	"namespace":"dewa",
	"version":"1.0.0",
	"image":"144436415367.dkr.ecr.us-west-2.amazonaws.com/dewa:1.0.0",
	"persistent":false
}
```
*/
func (a *Client) CreateImage(params *CreateImageParams, authInfo runtime.ClientAuthInfoWriter) (*CreateImageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateImageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateImage",
		Method:             "POST",
		PathPattern:        "/dsmcontroller/admin/images",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateImageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateImageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for CreateImage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteImage deletes an image

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [UPDATE]

Required scope: social

This endpoint will delete an image that specified in the request parameter
*/
func (a *Client) DeleteImage(params *DeleteImageParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteImageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteImageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteImage",
		Method:             "DELETE",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/images",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteImageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteImageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteImage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ExportImages exports d s m controller images for a namespace

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint export a dedicated servers images in a namespace.

*/
func (a *Client) ExportImages(params *ExportImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ExportImagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportImagesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExportImages",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/images/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExportImagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportImagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ExportImages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetConfig gets config for a namespace

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint get a dedicated servers config in a namespace.
*/
func (a *Client) GetConfig(params *GetConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetConfig",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetImageDetail ds s image detail

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint get specific version of dedicated servers images.
*/
func (a *Client) GetImageDetail(params *GetImageDetailParams, authInfo runtime.ClientAuthInfoWriter) (*GetImageDetailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetImageDetailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetImageDetail",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/images/versions/{version}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetImageDetailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetImageDetailOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetImageDetail: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetImageLimit ds s image limit

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint get ds image limit for specific namespace
*/
func (a *Client) GetImageLimit(params *GetImageLimitParams, authInfo runtime.ClientAuthInfoWriter) (*GetImageLimitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetImageLimitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetImageLimit",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/images/limit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetImageLimitReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetImageLimitOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetImageLimit: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImportImages imports images for a namespace

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [CREATE]

Required scope: social

This endpoint import a dedicated servers images in a namespace.

The image will be upsert. Existing version will be replaced with imported image, will create new one if not found.

Example data inside imported file
[
  {
	"namespace": "dewa",
	"image": "123456789.dkr.ecr.us-west-2.amazonaws.com/ds-dewa:0.0.1-alpha",
	"version": "0.0.1",
	"persistent": true
  }
]

*/
func (a *Client) ImportImages(params *ImportImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ImportImagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportImagesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImportImages",
		Method:             "POST",
		PathPattern:        "/dsmcontroller/admin/images/import",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ImportImagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportImagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImportImages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ListConfig lists all configs

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint lists all of dedicated servers configs.
*/
func (a *Client) ListConfig(params *ListConfigParams, authInfo runtime.ClientAuthInfoWriter) (*ListConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListConfig",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ListImages lists all d s images

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint lists all of dedicated servers images.
*/
func (a *Client) ListImages(params *ListImagesParams, authInfo runtime.ClientAuthInfoWriter) (*ListImagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListImagesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListImages",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/images",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListImagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListImagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListImages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SaveConfig saves config

  ```
Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [CREATE]
Required scope: social

This endpoint adds/modifies config. When there are ready servers and
the server version is updated, those servers will be replaced with newer version.

Port is where your game listens for incoming UDP connection, if empty it'll be set to 15000

CPU and Memory limit / request are formatted with Kubernetes format,
e.g. CPU of 1000m is 1 core, and Memory of 512Mi is 512 MB.

The creation/claim/session/unreachable/heartbeat timeouts are all in seconds.
Creation timeout is time limit for DS to startup until registers itself.
Claim timeout is time limit for game session manager to claim its ready DS.
Session timeout is time limit for match session before deleted.
Unreachable timeout is time limit for DS in UNREACHABLE state before deleted.
Heartbeat timeout is time limit for DS to give heartbeat before marked as UNREACHABLE.

Sample config:
{
	"namespace": "accelbyte",
	"providers": [
	"aws"
	],
	"port": 7777,
	"protocol": "udp",
	"creation_timeout": 120,
	"claim_timeout": 60,
	"session_timeout": 1800,
	"heartbeat_timeout": 30,
	"unreachable_timeout": 30,
	"image_version_mapping": {
		"1.4.0": "accelbyte/sample-ds-go:1.4.0"
	},
	"default_version": "1.4.0",
	"cpu_limit": "100",
	"mem_limit": "64",
	"artifact_path":"/srv/datads/artifacts/",
	"params": "",
	"min_count": 0,
	"max_count": 0,
	"buffer_count": 0,
	"configurations": {
		"1player": {
			"cpu_limit": "100",
			"mem_limit": "64",
			"params": "-gamemode 1p",
			"artifact_path":"/srv/datads/artifacts/",
		},
		"50players": {
			"cpu_limit": "200",
			"mem_limit": "512",
			"params": "-gamemode 50p",
			"artifact_path":"/srv/datads/artifacts/",
		}
	},
	"deployments": {
		"global-1p": {
			"game_version": "1.4.0"",
			"regions": ["us-west", "ap-southeast"],
			"configuration": "1player",
			"min_count": 0,
			"max_count": 0,
			"buffer_count": 2
		},
		"us-50p": {
			"game_version": "1.4.0"",
			"regions": ["us-west"],
			"configuration": "50players",
			"min_count": 0,
			"max_count": 0,
			"buffer_count": 5
		},
	},
}
```
*/
func (a *Client) SaveConfig(params *SaveConfigParams, authInfo runtime.ClientAuthInfoWriter) (*SaveConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSaveConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SaveConfig",
		Method:             "POST",
		PathPattern:        "/dsmcontroller/admin/configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SaveConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SaveConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for SaveConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateConfig updates config

  ```
Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [UPDATE]
Required scope: social

This endpoint modifies config. When there are ready servers and
the server version is updated, those servers will be replaced with newer version.

Port is where your game listens for incoming UDP connection, if empty it'll be set to 15000

CPU and Memory limit / request are formatted with Kubernetes format,
e.g. CPU of 1000m is 1 core, and Memory of 512Mi is 512 MB.

The creation/claim/session/unreachable/heartbeat timeouts are all in seconds.
Creation timeout is time limit for DS to startup until registers itself.
Claim timeout is time limit for game session manager to claim its ready DS.
Session timeout is time limit for match session before deleted.
Unreachable timeout is time limit for DS in UNREACHABLE state before deleted.
Heartbeat timeout is time limit for DS to give heartbeat before marked as UNREACHABLE.

Sample config:
{
	"namespace": "accelbyte",
	"providers": [
	"aws"
	],
	"port": 7777,
	"protocol": "udp",
	"creation_timeout": 120,
	"claim_timeout": 60,
	"session_timeout": 1800,
	"heartbeat_timeout": 30,
	"unreachable_timeout": 30,
	"image_version_mapping": {
		"1.4.0": "accelbyte/sample-ds-go:1.4.0"
	},
	"default_version": "1.4.0",
	"cpu_limit": "100",
	"mem_limit": "64",
	"artifact_path":"/srv/datads/artifacts/",
	"params": "",
	"min_count": 0,
	"max_count": 0,
	"buffer_count": 0,
	"configurations": {
		"1player": {
			"cpu_limit": "100",
			"mem_limit": "64",
			"params": "-gamemode 1p",
			"artifact_path":"/srv/datads/artifacts/",
		},
		"50players": {
			"cpu_limit": "200",
			"mem_limit": "512",
			"params": "-gamemode 50p",
			"artifact_path":"/srv/datads/artifacts/",
		}
	},
	"deployments": {
		"global-1p": {
			"game_version": "1.4.0"",
			"regions": ["us-west", "ap-southeast"],
			"configuration": "1player",
			"min_count": 0,
			"max_count": 0,
			"buffer_count": 2
		},
		"us-50p": {
			"game_version": "1.4.0"",
			"regions": ["us-west"],
			"configuration": "50players",
			"min_count": 0,
			"max_count": 0,
			"buffer_count": 5
		},
	},
}
```
*/
func (a *Client) UpdateConfig(params *UpdateConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateConfig",
		Method:             "PATCH",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateDeployment updates deployment

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [UPDATE]

Required scope: social

This endpoint update a dedicated servers deployment in a namespace.
*/
func (a *Client) UpdateDeployment(params *UpdateDeploymentParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateDeploymentNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDeploymentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateDeployment",
		Method:             "PATCH",
		PathPattern:        "/dsmcontroller/admin/namespaces/{namespace}/configs/deployments/{deployment}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDeploymentNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateDeployment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateImage updates image

  ```
Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [UPDATE]
Required scope: social

This endpoint will update an image name and/or image persistent flag.

Sample image:
{
	"namespace":"dewa",
	"version":"1.0.0",
	"image":"144436415367.dkr.ecr.us-west-2.amazonaws.com/dewa:1.0.0",
	"persistent":false
}
```
*/
func (a *Client) UpdateImage(params *UpdateImageParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateImageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateImageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateImage",
		Method:             "PUT",
		PathPattern:        "/dsmcontroller/admin/images",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateImageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateImageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateImage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ExportConfigV1 exports d s m controller configuration for a namespace

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [READ]

Required scope: social

This endpoint export a dedicated servers config in a namespace.

*/
func (a *Client) ExportConfigV1(params *ExportConfigV1Params, authInfo runtime.ClientAuthInfoWriter) (*ExportConfigV1OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportConfigV1Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "exportConfigV1",
		Method:             "GET",
		PathPattern:        "/dsmcontroller/admin/v1/namespaces/{namespace}/configs/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExportConfigV1Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportConfigV1OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportConfigV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImportConfigV1 imports config for a namespace

  Required permission: ADMIN:NAMESPACE:{namespace}:DSM:CONFIG [CREATE]

Required scope: social

This endpoint import a dedicated servers config in a namespace.

The configurations would be replaced except Image Version Mapping. The existing Image Version Mapping will be kept.

*/
func (a *Client) ImportConfigV1(params *ImportConfigV1Params, authInfo runtime.ClientAuthInfoWriter) (*ImportConfigV1OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportConfigV1Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "importConfigV1",
		Method:             "POST",
		PathPattern:        "/dsmcontroller/admin/v1/namespaces/{namespace}/configs/import",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ImportConfigV1Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportConfigV1OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importConfigV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
