// Code generated by go-swagger; DO NOT EDIT.

package platformclientmodels

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FullAppInfo full app info
//
// swagger:model FullAppInfo
type FullAppInfo struct {

	// carousel
	Carousel []*Slide `json:"carousel"`

	// developer
	Developer string `json:"developer,omitempty"`

	// forum url
	ForumURL string `json:"forumUrl,omitempty"`

	// genres
	Genres []string `json:"genres"`

	// item id
	// Required: true
	ItemID *string `json:"itemId"`

	// localizations
	Localizations map[string]AppLocalization `json:"localizations,omitempty"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// platform requirements
	PlatformRequirements map[string][]Requirement `json:"platformRequirements,omitempty"`

	// supported platforms
	Platforms []string `json:"platforms"`

	// players
	Players []string `json:"players"`

	// primary genre
	// Enum: [Action Adventure Casual FreeToPlay Indie MassivelyMultiplayer Racing RPG Simulation Sports Strategy]
	PrimaryGenre string `json:"primaryGenre,omitempty"`

	// publisher
	Publisher string `json:"publisher,omitempty"`

	// release date
	// Format: date-time
	ReleaseDate *strfmt.DateTime `json:"releaseDate,omitempty"`

	// website url
	WebsiteURL string `json:"websiteUrl,omitempty"`
}

// Validate validates this full app info
func (m *FullAppInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCarousel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGenres(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalizations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformRequirements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatforms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlayers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryGenre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullAppInfo) validateCarousel(formats strfmt.Registry) error {

	if swag.IsZero(m.Carousel) { // not required
		return nil
	}

	for i := 0; i < len(m.Carousel); i++ {
		if swag.IsZero(m.Carousel[i]) { // not required
			continue
		}

		if m.Carousel[i] != nil {
			if err := m.Carousel[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("carousel" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var fullAppInfoGenresItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Action","Adventure","Casual","FreeToPlay","Indie","MassivelyMultiplayer","Racing","RPG","Simulation","Sports","Strategy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fullAppInfoGenresItemsEnum = append(fullAppInfoGenresItemsEnum, v)
	}
}

func (m *FullAppInfo) validateGenresItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fullAppInfoGenresItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FullAppInfo) validateGenres(formats strfmt.Registry) error {

	if swag.IsZero(m.Genres) { // not required
		return nil
	}

	for i := 0; i < len(m.Genres); i++ {

		// value enum
		if err := m.validateGenresItemsEnum("genres"+"."+strconv.Itoa(i), "body", m.Genres[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *FullAppInfo) validateItemID(formats strfmt.Registry) error {

	if err := validate.Required("itemId", "body", m.ItemID); err != nil {
		return err
	}

	return nil
}

func (m *FullAppInfo) validateLocalizations(formats strfmt.Registry) error {

	if swag.IsZero(m.Localizations) { // not required
		return nil
	}

	for k := range m.Localizations {

		if err := validate.Required("localizations"+"."+k, "body", m.Localizations[k]); err != nil {
			return err
		}
		if val, ok := m.Localizations[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *FullAppInfo) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *FullAppInfo) validatePlatformRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.PlatformRequirements) { // not required
		return nil
	}

	for k := range m.PlatformRequirements {

		if err := validate.Required("platformRequirements"+"."+k, "body", m.PlatformRequirements[k]); err != nil {
			return err
		}

		for i := 0; i < len(m.PlatformRequirements[k]); i++ {

			if err := m.PlatformRequirements[k][i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("platformRequirements" + "." + k + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var fullAppInfoPlatformsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Windows","MacOS","Linux","IOS","Android"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fullAppInfoPlatformsItemsEnum = append(fullAppInfoPlatformsItemsEnum, v)
	}
}

func (m *FullAppInfo) validatePlatformsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fullAppInfoPlatformsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FullAppInfo) validatePlatforms(formats strfmt.Registry) error {

	if swag.IsZero(m.Platforms) { // not required
		return nil
	}

	for i := 0; i < len(m.Platforms); i++ {

		// value enum
		if err := m.validatePlatformsItemsEnum("platforms"+"."+strconv.Itoa(i), "body", m.Platforms[i]); err != nil {
			return err
		}

	}

	return nil
}

var fullAppInfoPlayersItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Single","Multi","CrossPlatformMulti","MMO","Coop","LocalCoop"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fullAppInfoPlayersItemsEnum = append(fullAppInfoPlayersItemsEnum, v)
	}
}

func (m *FullAppInfo) validatePlayersItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fullAppInfoPlayersItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FullAppInfo) validatePlayers(formats strfmt.Registry) error {

	if swag.IsZero(m.Players) { // not required
		return nil
	}

	for i := 0; i < len(m.Players); i++ {

		// value enum
		if err := m.validatePlayersItemsEnum("players"+"."+strconv.Itoa(i), "body", m.Players[i]); err != nil {
			return err
		}

	}

	return nil
}

var fullAppInfoTypePrimaryGenrePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Action","Adventure","Casual","FreeToPlay","Indie","MassivelyMultiplayer","Racing","RPG","Simulation","Sports","Strategy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fullAppInfoTypePrimaryGenrePropEnum = append(fullAppInfoTypePrimaryGenrePropEnum, v)
	}
}

const (

	// FullAppInfoPrimaryGenreAction captures enum value "Action"
	FullAppInfoPrimaryGenreAction string = "Action"

	// FullAppInfoPrimaryGenreAdventure captures enum value "Adventure"
	FullAppInfoPrimaryGenreAdventure string = "Adventure"

	// FullAppInfoPrimaryGenreCasual captures enum value "Casual"
	FullAppInfoPrimaryGenreCasual string = "Casual"

	// FullAppInfoPrimaryGenreFreeToPlay captures enum value "FreeToPlay"
	FullAppInfoPrimaryGenreFreeToPlay string = "FreeToPlay"

	// FullAppInfoPrimaryGenreIndie captures enum value "Indie"
	FullAppInfoPrimaryGenreIndie string = "Indie"

	// FullAppInfoPrimaryGenreMassivelyMultiplayer captures enum value "MassivelyMultiplayer"
	FullAppInfoPrimaryGenreMassivelyMultiplayer string = "MassivelyMultiplayer"

	// FullAppInfoPrimaryGenreRacing captures enum value "Racing"
	FullAppInfoPrimaryGenreRacing string = "Racing"

	// FullAppInfoPrimaryGenreRPG captures enum value "RPG"
	FullAppInfoPrimaryGenreRPG string = "RPG"

	// FullAppInfoPrimaryGenreSimulation captures enum value "Simulation"
	FullAppInfoPrimaryGenreSimulation string = "Simulation"

	// FullAppInfoPrimaryGenreSports captures enum value "Sports"
	FullAppInfoPrimaryGenreSports string = "Sports"

	// FullAppInfoPrimaryGenreStrategy captures enum value "Strategy"
	FullAppInfoPrimaryGenreStrategy string = "Strategy"
)

// prop value enum
func (m *FullAppInfo) validatePrimaryGenreEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fullAppInfoTypePrimaryGenrePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FullAppInfo) validatePrimaryGenre(formats strfmt.Registry) error {

	if swag.IsZero(m.PrimaryGenre) { // not required
		return nil
	}

	// value enum
	if err := m.validatePrimaryGenreEnum("primaryGenre", "body", m.PrimaryGenre); err != nil {
		return err
	}

	return nil
}

func (m *FullAppInfo) validateReleaseDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ReleaseDate) { // not required
		return nil
	}

	if err := validate.FormatOf("releaseDate", "body", "date-time", m.ReleaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullAppInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullAppInfo) UnmarshalBinary(b []byte) error {
	var res FullAppInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
