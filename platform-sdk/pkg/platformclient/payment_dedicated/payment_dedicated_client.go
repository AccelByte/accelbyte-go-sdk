// Code generated by go-swagger; DO NOT EDIT.

package payment_dedicated

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new payment dedicated API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for payment dedicated API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreatePaymentOrderByDedicated(params *CreatePaymentOrderByDedicatedParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePaymentOrderByDedicatedCreated, *CreatePaymentOrderByDedicatedBadRequest, *CreatePaymentOrderByDedicatedForbidden, *CreatePaymentOrderByDedicatedNotFound, *CreatePaymentOrderByDedicatedConflict, *CreatePaymentOrderByDedicatedUnprocessableEntity, error)

	RefundPaymentOrderByDedicated(params *RefundPaymentOrderByDedicatedParams, authInfo runtime.ClientAuthInfoWriter) (*RefundPaymentOrderByDedicatedOK, *RefundPaymentOrderByDedicatedNoContent, *RefundPaymentOrderByDedicatedNotFound, *RefundPaymentOrderByDedicatedConflict, *RefundPaymentOrderByDedicatedUnprocessableEntity, error)

	SyncPaymentOrders(params *SyncPaymentOrdersParams, authInfo runtime.ClientAuthInfoWriter) (*SyncPaymentOrdersOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreatePaymentOrderByDedicated creates payment order by dedicated server

  <p>This API is used to create payment order from non justice service. e.g. from dedicated server, the result contains the payment station url.</p><p><strong>Path Parameter:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Namespace that payment order resides in, should be publisher namespace if it's a Steam like platform that share <br>payment config cross namespaces, otherwise it's the game namespace</td></tr></table><p><strong>Request Body Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>extOrderNo</td><td>String</td><td>Yes</td><td>External order number, it should be unique in invoker order system</td></tr><tr><td>sku</td><td>String</td><td>No</td><td>Item identity</td></tr><tr><td>targetNamespace</td><td>String</td><td>Yes</td><td>The game namespace</td></tr><tr><td>targetUserId</td><td>String</td><td>Yes</td><td>User id for the order owner in game namespace</td></tr><tr><td>extUserId</td><td>String</td><td>No</td><td>External user id, can be user character id </td></tr><tr><td>price</td><td>int</td><td>Yes</td><td>price which should be greater than 0</td></tr><tr><td>title</td><td>String</td><td>Yes</td><td>Item title</td></tr><tr><td>description</td><td>String</td><td>Yes</td><td>Item description</td></tr><tr><td>currencyCode</td><td>String</td><td>No</td><td>Currency code, default is USD</td></tr><tr><td>currencyNamespace</td><td>String</td><td>No</td><td>Currency namespace, default is publisher namespace</td></tr><tr><td>region</td><td>String</td><td>No</td><td>Country of the user, will get from user info if not present</td></tr><tr><td>language</td><td>String</td><td>No</td><td>Language of the user</td></tr><tr><td>sandbox</td><td>Boolean</td><td>No</td><td>set to true will create sandbox order that not real paid for xsolla/alipay and will not validate <br>price for wxpay.</td></tr><tr><td>returnUrl</td><td>String</td><td>No</td><td>customized return url for redirect once payment finished, leave unset to use configuration in <br>namespace</td></tr><tr><td>notifyUrl</td><td>String</td><td>No</td><td>customized notify url for payment web hook, leave unset to use configuration in namespace</td></tr><tr><td>customParameters</td><td>String</td><td>No</td><td>Custom parameters</td></tr></table></pre><p><strong>Request Body Example:</strong></p><pre><code style='overflow: auto'>{
           "extOrderNo": "123456789",
           "sku": "sku",
           "targetNamespace": "game1",
           "targetUserId": "94451623768940d58416ca33ca767ec3",
           "extUserId": "678",
           "title": "Frostmourne",
           "description\": "Here was power. Here was despair",
           "price": 100,
           "region": "CN",
           "language": "zh-CN",
           "currencyCode": "USD",
           "currencyNamespace": "accelbyte"
}</pre></code><h4>Payment Notification:</h4><p>After user complete the payment, it will send notification to configured web hook, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval</p><p><strong>Payment notification parameter:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>payload</td><td>String</td><td>Yes</td><td>Payment notification payload in json string </td></tr><tr><td>sign</td><td>String</td><td>Yes</td><td>sha1 hex signature for payload and private key</td></tr></table></pre><p><strong>Payment notification parameter Example:</strong></p><pre><code style='overflow: auto'>{
       "payload": "{
           \"type\": \"payment\",
           \"nonceStr\": \"34c1dcf3eb58455eb161465bbfc0b590\",
           \"paymentOrderNo\": \"18081239088\",
           \"namespace\": \"accelbyte\",
           \"targetNamespace\": \"game1\",
           \"targetUserId\": \"94451623768940d58416ca33ca767ec3\",
           \"extOrderNo\": \"123456789\",
           \"sku\": \"sku\",
           \"extUserId\": \"678\",
           \"price\": 100,
           \"paymentProvider\": \"XSOLLA\",
           \"vat\": 0,
           \"salesTax\": 0,
           \"paymentProviderFee\": 0,
           \"paymentMethodFee\": 0,
           \"currency\": {
                   \"currencyCode\": \"USD\",
                   \"currencySymbol\": \"$\",
                   \"currencyType\": \"REAL\",
                   \"namespace\": \"accelbyte\",
                   \"decimals\": 2
               },
           \"status\": \"CHARGED\",
           \"createdTime\": \"2018-07-28T00:39:16.274Z\",
           \"chargedTime\": \"2018-07-28T00:39:16.274Z\"
       }",
       "sign":"e31fb92516cc9faaf50ad70343e1293acec6f3d5"
}</pre></code><p><strong>Payment notification payload parameter list:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>type</td><td>String</td><td>Yes</td><td>Notification type: 'payment'</td></tr><tr><td>paymentOrderNo</td><td>String</td><td>Yes</td><td>Payment system generated order number</td></tr><tr><td>extOrderNo</td><td>String</td><td>No</td><td>External order number that passed by invoker</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Namespace that related payment order resides in</td></tr><tr><td>targetNamespace</td><td>String</td><td>Yes</td><td>The game namespace</td></tr><tr><td>targetUserId</td><td>String</td><td>Yes</td><td>The user id in game namespace</td></tr><tr><td>sku</td><td>String</td><td>No</td><td>Item identify, it will return if pass it when create payment</td></tr><tr><td>extUserId</td><td>String</td><td>No</td><td>External user id, can be character id, it will return if pass it when create payment</td></tr><tr><td>price</td><td>int</td><td>Yes</td><td>Price of item</td></tr><tr><td>paymentProvider</td><td>String</td><td>Yes</td><td>Payment provider, allowed values: xsolla/alipay/wxpay/wallet</td></tr><tr><td>vat</td><td>int</td><td>Yes</td><td>Payment order VAT</td></tr><tr><td>salesTax</td><td>int</td><td>Yes</td><td>Payment order sales tax</td></tr><tr><td>paymentProviderFee</td><td>int</td><td>Yes</td><td>Payment provider fee</td></tr><tr><td>paymentMethodFee</td><td>int</td><td>Yes</td><td>Payment method fee</td></tr><tr><td>currency</td><td>Map</td><td>Yes</td><td>Payment order currency info</td></tr><tr><td>status</td><td>String</td><td>Yes</td><td>Payment order status</td></tr><tr><td>statusReason</td><td>String</td><td>No</td><td>Payment order status reason</td></tr><tr><td>createdTime</td><td>Datetime</td><td>No</td><td>The time of the order created</td></tr><tr><td>chargedTime</td><td>Datetime</td><td>No</td><td>The time of the order charged</td></tr><tr><td>customParameters</td><td>Map</td><td>No</td><td>custom parameters, will return if pass it when create payment</td></tr><tr><td>nonceStr</td><td>String</td><td>Yes</td><td>Random string, max length is 32, can be timestamp or uuid</td></tr></table></pre><p><strong>Currency info parameter list:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>currencyCode</td><td>String</td><td>Yes</td><td>Currency Code</td></tr><tr><td>currencySymbol</td><td>String</td><td>Yes</td><td>Currency Symbol</td></tr><tr><td>currencyType</td><td>String</td><td>Yes</td><td>Currency type(REAL/VIRTUAL)</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Currency namespace</td></tr><tr><td>decimals</td><td>int</td><td>Yes</td><td>Currency decimals</td></tr></table></pre><h4>Encryption Rule:</h4><p>Concat payload json string and private key and then do sha1Hex.</p><h4>Other detail info:</h4> <ul><li><i>Token type</i>: client token</li><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:PAYMENT", action=1 (CREATE)</li><li><i>Optional permission(user with this permission will create sandbox order)</i>: resource="SANDBOX", action=1 (CREATE)</li><li>It will be forbidden while the target user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT</li><li><b>cross namespace allowed</b></li><li><i>Returns</i>: created payment order info</li></ul>
*/
func (a *Client) CreatePaymentOrderByDedicated(params *CreatePaymentOrderByDedicatedParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePaymentOrderByDedicatedCreated, *CreatePaymentOrderByDedicatedBadRequest, *CreatePaymentOrderByDedicatedForbidden, *CreatePaymentOrderByDedicatedNotFound, *CreatePaymentOrderByDedicatedConflict, *CreatePaymentOrderByDedicatedUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePaymentOrderByDedicatedParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPaymentOrderByDedicated",
		Method:             "POST",
		PathPattern:        "/admin/namespaces/{namespace}/payment/orders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreatePaymentOrderByDedicatedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreatePaymentOrderByDedicatedCreated:
		return v, nil, nil, nil, nil, nil, nil
	case *CreatePaymentOrderByDedicatedBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *CreatePaymentOrderByDedicatedForbidden:
		return nil, nil, v, nil, nil, nil, nil
	case *CreatePaymentOrderByDedicatedNotFound:
		return nil, nil, nil, v, nil, nil, nil
	case *CreatePaymentOrderByDedicatedConflict:
		return nil, nil, nil, nil, v, nil, nil
	case *CreatePaymentOrderByDedicatedUnprocessableEntity:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  RefundPaymentOrderByDedicated refunds payment order by dedicated server

  <p>This API is used to refund payment order by paymentOrderNo from non justice service. e.g. dedicated server. <ul><li>if the status field of response json is "REFUNDED", usually wallet paid, it indicates payment order already refunded</li><li>if the status field of response json is "REFUNDING", usually real money paid, platform will send notification to registered notify url once refund successfully</li> </ul></p><p><strong>Path Parameter:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Namespace that payment order resides in</td></tr><tr><td>paymentOrderNo</td><td>String</td><td>Yes</td><td>Payment order number</td></tr></table></pre><p><strong>Request Body Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>description</td><td>String</td><td>Yes</td><td>Refund description</td></tr></table></pre><p><strong>Request Body Example:</strong></p><pre><code style='overflow: auto'>{
           "description": "Repeated item."
}</pre></code><h4>Refund Notification:</h4><p>It will send notification to configured web hook after refund successfully, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval</p><p><strong>Refund notification parameter:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>payload</td><td>String</td><td>Yes</td><td>Refund notification payload in json string </td></tr><tr><td>sign</td><td>String</td><td>Yes</td><td>sha1 hex signature for payload and private key</td></tr></table></pre><p><strong>Refund notification Example:</strong></p><pre><code style='overflow: auto'>{
       "payload": "{
           \"type\": \"payment\",
           \"nonceStr\": \"34c1dcf3eb58455eb161465bbfc0b590\",
           \"paymentOrderNo\": \"18081239088\",
           \"namespace\": \"accelbyte\",
           \"targetNamespace\": \"game1\",
           \"targetUserId\": \"94451623768940d58416ca33ca767ec3\",
           \"extOrderNo\": \"123456789\",
           \"sku\": \"sku\",
           \"extUserId\": \"678\",
           \"price\": 100,
           \"paymentProvider\": \"XSOLLA\",
           \"vat\": 0,
           \"salesTax\": 0,
           \"paymentProviderFee\": 0,
           \"paymentMethodFee\": 0,
           \"currency\": {
                   \"currencyCode\": \"USD\",
                   \"currencySymbol\": \"$\",
                   \"currencyType\": \"REAL\",
                   \"namespace\": \"accelbyte\",
                   \"decimals\": 2
               },
           \"status\": \"REFUNDED\",
           \"createdTime\": \"2018-07-28T00:39:16.274Z\",
           \"chargedTime\": \"2018-07-28T00:39:16.274Z\",
           \"refundedTime\": \"2018-07-28T00:39:16.274Z\"
       }",
       "sign":"e31fb92516cc9faaf50ad70343e1293acec6f3d5"
}</pre></code><p><strong>Refund notification payload parameter list:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>type</td><td>String</td><td>Yes</td><td>Notification type: 'payment'</td></tr><tr><td>paymentOrderNo</td><td>String</td><td>Yes</td><td>Payment system generated order number</td></tr><tr><td>extOrderNo</td><td>String</td><td>No</td><td>External order number that passed by invoker</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Namespace that related payment order resides in</td></tr><tr><td>targetNamespace</td><td>String</td><td>Yes</td><td>The game namespace</td></tr><tr><td>targetUserId</td><td>String</td><td>Yes</td><td>The user id in game namespace</td></tr><tr><td>sku</td><td>String</td><td>No</td><td>Item identify, it will return if pass it when create payment</td></tr><tr><td>extUserId</td><td>String</td><td>No</td><td>External user id, can be character id, it will return if pass it when create payment</td></tr><tr><td>price</td><td>int</td><td>Yes</td><td>Price of item</td></tr><tr><td>paymentProvider</td><td>String</td><td>Yes</td><td>Payment provider: xsolla/alipay/wxpay/wallet</td></tr><tr><td>vat</td><td>int</td><td>Yes</td><td>Payment order VAT</td></tr><tr><td>salesTax</td><td>int</td><td>Yes</td><td>Payment order sales tax</td></tr><tr><td>paymentProviderFee</td><td>int</td><td>Yes</td><td>Payment provider fee</td></tr><tr><td>paymentMethodFee</td><td>int</td><td>Yes</td><td>Payment method fee</td></tr><tr><td>currency</td><td>Map</td><td>Yes</td><td>Payment order currency info</td></tr><tr><td>status</td><td>String</td><td>Yes</td><td>Payment order status</td></tr><tr><td>statusReason</td><td>String</td><td>No</td><td>Payment order refund status reason</td></tr><tr><td>createdTime</td><td>Datetime</td><td>No</td><td>The time of the order created</td></tr><tr><td>chargedTime</td><td>Datetime</td><td>No</td><td>The time of the order charged</td></tr><tr><td>refundedTime</td><td>Datetime</td><td>No</td><td>The time of the order refunded</td></tr><tr><td>customParameters</td><td>Map</td><td>No</td><td>custom parameters, will return if pass it when create payment</td></tr><tr><td>nonceStr</td><td>String</td><td>Yes</td><td>Random string, max length is 32, </td></tr></table></pre><p><strong>Currency info parameter list:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>currencyCode</td><td>String</td><td>Yes</td><td>Currency Code</td></tr><tr><td>currencySymbol</td><td>String</td><td>Yes</td><td>Currency Symbol</td></tr><tr><td>currencyType</td><td>String</td><td>Yes</td><td>Currency type(REAL/VIRTUAL)</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>Currency namespace</td></tr><tr><td>decimals</td><td>int</td><td>Yes</td><td>Currency decimals</td></tr></table></pre><h4>Encryption Rule:</h4><p>Concat payload json string and private key and then do sha1Hex.</p><h4>Other detail info:</h4> <ul><li><i>Token type</i>: client token</li><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:PAYMENT", action=4 (UPDATE)</li><li><b>cross namespace allowed</b></li></ul>
*/
func (a *Client) RefundPaymentOrderByDedicated(params *RefundPaymentOrderByDedicatedParams, authInfo runtime.ClientAuthInfoWriter) (*RefundPaymentOrderByDedicatedOK, *RefundPaymentOrderByDedicatedNoContent, *RefundPaymentOrderByDedicatedNotFound, *RefundPaymentOrderByDedicatedConflict, *RefundPaymentOrderByDedicatedUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRefundPaymentOrderByDedicatedParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "refundPaymentOrderByDedicated",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/refund",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RefundPaymentOrderByDedicatedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *RefundPaymentOrderByDedicatedOK:
		return v, nil, nil, nil, nil, nil
	case *RefundPaymentOrderByDedicatedNoContent:
		return nil, v, nil, nil, nil, nil
	case *RefundPaymentOrderByDedicatedNotFound:
		return nil, nil, v, nil, nil, nil
	case *RefundPaymentOrderByDedicatedConflict:
		return nil, nil, nil, v, nil, nil
	case *RefundPaymentOrderByDedicatedUnprocessableEntity:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SyncPaymentOrders syncs payment orders

  Sync payment orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT", action=2 (READ)</li><li><i>Returns</i>: sync payment orders</li></ul>
*/
func (a *Client) SyncPaymentOrders(params *SyncPaymentOrdersParams, authInfo runtime.ClientAuthInfoWriter) (*SyncPaymentOrdersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncPaymentOrdersParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "syncPaymentOrders",
		Method:             "GET",
		PathPattern:        "/admin/payment/orders",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SyncPaymentOrdersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *SyncPaymentOrdersOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
