// Code generated by go-swagger; DO NOT EDIT.

package payment_config

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new payment config API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for payment config API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreatePaymentProviderConfig(params *CreatePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePaymentProviderConfigOK, *CreatePaymentProviderConfigBadRequest, *CreatePaymentProviderConfigConflict, *CreatePaymentProviderConfigUnprocessableEntity, error)

	DebugMatchedPaymentMerchantConfig(params *DebugMatchedPaymentMerchantConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DebugMatchedPaymentMerchantConfigOK, *DebugMatchedPaymentMerchantConfigNotFound, error)

	DebugMatchedPaymentProviderConfig(params *DebugMatchedPaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DebugMatchedPaymentProviderConfigOK, *DebugMatchedPaymentProviderConfigNotFound, error)

	DeletePaymentProviderConfig(params *DeletePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DeletePaymentProviderConfigNoContent, *DeletePaymentProviderConfigNotFound, error)

	GetAggregatePaymentProviders(params *GetAggregatePaymentProvidersParams, authInfo runtime.ClientAuthInfoWriter) (*GetAggregatePaymentProvidersOK, error)

	GetPaymentMerchantConfig(params *GetPaymentMerchantConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetPaymentMerchantConfigOK, *GetPaymentMerchantConfigNotFound, error)

	GetPaymentTaxConfig(params *GetPaymentTaxConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetPaymentTaxConfigOK, error)

	GetSpecialPaymentProviders(params *GetSpecialPaymentProvidersParams, authInfo runtime.ClientAuthInfoWriter) (*GetSpecialPaymentProvidersOK, error)

	QueryPaymentProviderConfig(params *QueryPaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*QueryPaymentProviderConfigOK, error)

	TestAdyenConfig(params *TestAdyenConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestAdyenConfigOK, error)

	TestAdyenConfigByID(params *TestAdyenConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestAdyenConfigByIDOK, *TestAdyenConfigByIDNotFound, error)

	TestAliPayConfig(params *TestAliPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestAliPayConfigOK, error)

	TestAliPayConfigByID(params *TestAliPayConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestAliPayConfigByIDOK, *TestAliPayConfigByIDNotFound, error)

	TestCheckoutConfig(params *TestCheckoutConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestCheckoutConfigOK, error)

	TestCheckoutConfigByID(params *TestCheckoutConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestCheckoutConfigByIDOK, *TestCheckoutConfigByIDNotFound, error)

	TestPayPalConfig(params *TestPayPalConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestPayPalConfigOK, error)

	TestPayPalConfigByID(params *TestPayPalConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestPayPalConfigByIDOK, *TestPayPalConfigByIDNotFound, error)

	TestStripeConfig(params *TestStripeConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestStripeConfigOK, error)

	TestStripeConfigByID(params *TestStripeConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestStripeConfigByIDOK, *TestStripeConfigByIDNotFound, error)

	TestWxPayConfig(params *TestWxPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestWxPayConfigOK, error)

	TestWxPayConfigByID(params *TestWxPayConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestWxPayConfigByIDOK, *TestWxPayConfigByIDNotFound, error)

	TestXsollaConfig(params *TestXsollaConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestXsollaConfigOK, error)

	TestXsollaConfigByID(params *TestXsollaConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestXsollaConfigByIDOK, *TestXsollaConfigByIDNotFound, error)

	UpdateAdyenConfig(params *UpdateAdyenConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAdyenConfigOK, *UpdateAdyenConfigNotFound, error)

	UpdateAliPayConfig(params *UpdateAliPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAliPayConfigOK, *UpdateAliPayConfigNotFound, error)

	UpdateCheckoutConfig(params *UpdateCheckoutConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateCheckoutConfigOK, *UpdateCheckoutConfigNotFound, error)

	UpdatePayPalConfig(params *UpdatePayPalConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePayPalConfigOK, *UpdatePayPalConfigNotFound, error)

	UpdatePaymentProviderConfig(params *UpdatePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePaymentProviderConfigOK, *UpdatePaymentProviderConfigBadRequest, *UpdatePaymentProviderConfigNotFound, *UpdatePaymentProviderConfigConflict, *UpdatePaymentProviderConfigUnprocessableEntity, error)

	UpdatePaymentTaxConfig(params *UpdatePaymentTaxConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePaymentTaxConfigOK, *UpdatePaymentTaxConfigBadRequest, *UpdatePaymentTaxConfigUnprocessableEntity, error)

	UpdateStripeConfig(params *UpdateStripeConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateStripeConfigOK, *UpdateStripeConfigNotFound, error)

	UpdateWxPayConfig(params *UpdateWxPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateWxPayConfigOK, *UpdateWxPayConfigNotFound, error)

	UpdateWxPayConfigCert(params *UpdateWxPayConfigCertParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateWxPayConfigCertOK, *UpdateWxPayConfigCertNotFound, error)

	UpdateXsollaConfig(params *UpdateXsollaConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateXsollaConfigOK, *UpdateXsollaConfigNotFound, error)

	UpdateXsollaUIConfig(params *UpdateXsollaUIConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateXsollaUIConfigOK, *UpdateXsollaUIConfigNotFound, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreatePaymentProviderConfig creates payment provider config

  Create payment provider config.<br><pre><p><strong>Request Body Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>namespace, * indicates all namespace</td></tr><tr><td>region</td><td>String</td><td>Yes</td><td>region, * indicates all regions</td></tr><tr><td>aggregate</td><td>String</td><td>No</td><td>aggregate payment provider, such as XSOLLA, ADYEN, STRIPE</td></tr><tr><td>specials</td><td>List</td><td>No</td><td>special payment provider, such as ALIPAY, WXPAY</td></tr></table></pre>payment provider applied has priority: <ol><li>namespace and region match</li><li>namespace matches and region is *</li><li>region matches and namespace is *</li><li>namespace and region are *</li></ol>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=1 (CREATE)</li><li><i>Returns</i>: payment provider config</li></ul>
*/
func (a *Client) CreatePaymentProviderConfig(params *CreatePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePaymentProviderConfigOK, *CreatePaymentProviderConfigBadRequest, *CreatePaymentProviderConfigConflict, *CreatePaymentProviderConfigUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePaymentProviderConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPaymentProviderConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreatePaymentProviderConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreatePaymentProviderConfigOK:
		return v, nil, nil, nil, nil
	case *CreatePaymentProviderConfigBadRequest:
		return nil, v, nil, nil, nil
	case *CreatePaymentProviderConfigConflict:
		return nil, nil, v, nil, nil
	case *CreatePaymentProviderConfigUnprocessableEntity:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DebugMatchedPaymentMerchantConfig debugs matched payment merchant config internal

  Debug matched payment merchant config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment merchant config info</li></ul>
*/
func (a *Client) DebugMatchedPaymentMerchantConfig(params *DebugMatchedPaymentMerchantConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DebugMatchedPaymentMerchantConfigOK, *DebugMatchedPaymentMerchantConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDebugMatchedPaymentMerchantConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "debugMatchedPaymentMerchantConfig",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/matched",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DebugMatchedPaymentMerchantConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *DebugMatchedPaymentMerchantConfigOK:
		return v, nil, nil
	case *DebugMatchedPaymentMerchantConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DebugMatchedPaymentProviderConfig debugs matched payment provider config internal

  Debug matched payment provider config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment provider config</li></ul>
*/
func (a *Client) DebugMatchedPaymentProviderConfig(params *DebugMatchedPaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DebugMatchedPaymentProviderConfigOK, *DebugMatchedPaymentProviderConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDebugMatchedPaymentProviderConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "debugMatchedPaymentProviderConfig",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/provider/matched",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DebugMatchedPaymentProviderConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *DebugMatchedPaymentProviderConfigOK:
		return v, nil, nil
	case *DebugMatchedPaymentProviderConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeletePaymentProviderConfig deletes payment provider config

  Delete payment provider config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=8 (DELETE)</li><li><i>Returns</i>: payment provider config</li></ul>
*/
func (a *Client) DeletePaymentProviderConfig(params *DeletePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DeletePaymentProviderConfigNoContent, *DeletePaymentProviderConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePaymentProviderConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deletePaymentProviderConfig",
		Method:             "DELETE",
		PathPattern:        "/admin/payment/config/provider/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePaymentProviderConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *DeletePaymentProviderConfigNoContent:
		return v, nil, nil
	case *DeletePaymentProviderConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAggregatePaymentProviders gets aggregate payment providers

  Get aggregate payment providers, such as XSOLLA, ADYEN.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment provider list</li></ul>
*/
func (a *Client) GetAggregatePaymentProviders(params *GetAggregatePaymentProvidersParams, authInfo runtime.ClientAuthInfoWriter) (*GetAggregatePaymentProvidersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAggregatePaymentProvidersParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAggregatePaymentProviders",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/provider/aggregate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAggregatePaymentProvidersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetAggregatePaymentProvidersOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetPaymentMerchantConfig gets payment merchant config

  Get payment merchant config by id.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment merchant config info</li></ul>
*/
func (a *Client) GetPaymentMerchantConfig(params *GetPaymentMerchantConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetPaymentMerchantConfigOK, *GetPaymentMerchantConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPaymentMerchantConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPaymentMerchantConfig",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPaymentMerchantConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetPaymentMerchantConfigOK:
		return v, nil, nil
	case *GetPaymentMerchantConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetPaymentTaxConfig gets payment global tax config

  Get payment global tax config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment provider list</li></ul>
*/
func (a *Client) GetPaymentTaxConfig(params *GetPaymentTaxConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetPaymentTaxConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPaymentTaxConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPaymentTaxConfig",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/tax",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPaymentTaxConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetPaymentTaxConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetSpecialPaymentProviders gets special payment providers

  Get special payment providers, such as ALIPAY, WXPAY.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment provider list</li></ul>
*/
func (a *Client) GetSpecialPaymentProviders(params *GetSpecialPaymentProvidersParams, authInfo runtime.ClientAuthInfoWriter) (*GetSpecialPaymentProvidersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSpecialPaymentProvidersParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSpecialPaymentProviders",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/provider/special",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSpecialPaymentProvidersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetSpecialPaymentProvidersOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryPaymentProviderConfig queries payment provider config

  Query payment provider config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: payment provider config list</li></ul>
*/
func (a *Client) QueryPaymentProviderConfig(params *QueryPaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*QueryPaymentProviderConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryPaymentProviderConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryPaymentProviderConfig",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QueryPaymentProviderConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *QueryPaymentProviderConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestAdyenConfig tests adyen configuration

  Test adyen configuration. <h4>Check List:</h4> <ul><li>apiKey</li><li>merchantAccount</li></ul><h4>Non-check list:</h4><ul><li>notificationHmacKey</li><li>notificationUsername</li><li>notificationPassword</li><li>liveEndpointUrlPrefix</li><li>allowedPaymentMethods</li><li>blockedPaymentMethods</li><li>settings</li></ul>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test adyen config</li></ul>
*/
func (a *Client) TestAdyenConfig(params *TestAdyenConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestAdyenConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestAdyenConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testAdyenConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/adyenconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestAdyenConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestAdyenConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestAdyenConfigByID tests adyen configuration by id

  Test adyen configuration in payment merchant config. Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test adyen config</li></ul>
*/
func (a *Client) TestAdyenConfigByID(params *TestAdyenConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestAdyenConfigByIDOK, *TestAdyenConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestAdyenConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testAdyenConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/adyenconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestAdyenConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestAdyenConfigByIDOK:
		return v, nil, nil
	case *TestAdyenConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestAliPayConfig tests alipay configuration

  Test AliPay configuration.Reference: <a href="https://docs.open.alipay.com/270/alipay.trade.page.pay">Alipay Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestAliPayConfig(params *TestAliPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestAliPayConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestAliPayConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testAliPayConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/alipayconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestAliPayConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestAliPayConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestAliPayConfigByID tests alipay configuration by id

  Test AliPay configuration in payment merchant config. Reference: <a href="https://docs.open.alipay.com/270/alipay.trade.page.pay">Alipay Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test alipay config</li></ul>
*/
func (a *Client) TestAliPayConfigByID(params *TestAliPayConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestAliPayConfigByIDOK, *TestAliPayConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestAliPayConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testAliPayConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/alipayconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestAliPayConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestAliPayConfigByIDOK:
		return v, nil, nil
	case *TestAliPayConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestCheckoutConfig tests checkout com configuration

  Test checkout.com configuration. <h4>Check List:</h4> <ul><li>publicKey</li><li>secretKey</li></ul>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestCheckoutConfig(params *TestCheckoutConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestCheckoutConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestCheckoutConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testCheckoutConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/checkoutconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestCheckoutConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestCheckoutConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestCheckoutConfigByID tests checkout com configuration by id

  Test checkout.com configuration in payment merchant config. Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestCheckoutConfigByID(params *TestCheckoutConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestCheckoutConfigByIDOK, *TestCheckoutConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestCheckoutConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testCheckoutConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/checkoutconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestCheckoutConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestCheckoutConfigByIDOK:
		return v, nil, nil
	case *TestCheckoutConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestPayPalConfig tests pay pal configuration

  Test PayPal configuration. <h4>Check List:</h4> <ul><li>clientID</li><li>clientSecret</li></ul><h4>Non-check list:</h4><ul><li>webHookId</li></ul>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestPayPalConfig(params *TestPayPalConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestPayPalConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestPayPalConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testPayPalConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/paypalconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestPayPalConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestPayPalConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestPayPalConfigByID tests pay pal configuration by id

  Test PayPal configuration in payment merchant config. Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestPayPalConfigByID(params *TestPayPalConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestPayPalConfigByIDOK, *TestPayPalConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestPayPalConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testPayPalConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/paypalconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestPayPalConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestPayPalConfigByIDOK:
		return v, nil, nil
	case *TestPayPalConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestStripeConfig tests stripe configuration

  Test stripe configuration. <h4>Check List:</h4> <ul><li>secretKey</li><li>allowedPaymentMethodTypes</li></ul><h4>Non-check list:</h4><ul><li>publishableKey</li><li>webhookSecret</li></ul>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test adyen config</li></ul>
*/
func (a *Client) TestStripeConfig(params *TestStripeConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestStripeConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestStripeConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testStripeConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/stripeconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestStripeConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestStripeConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestStripeConfigByID tests stripe configuration by id

  Test stripe configuration in payment merchant config. Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test adyen config</li></ul>
*/
func (a *Client) TestStripeConfigByID(params *TestStripeConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestStripeConfigByIDOK, *TestStripeConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestStripeConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testStripeConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/stripeconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestStripeConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestStripeConfigByIDOK:
		return v, nil, nil
	case *TestStripeConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestWxPayConfig tests wx pay configuration

  Test WxPay configuration. Reference: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1">WxPay Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test WxPay config</li></ul>
*/
func (a *Client) TestWxPayConfig(params *TestWxPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestWxPayConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestWxPayConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testWxPayConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/wxpayconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestWxPayConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestWxPayConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestWxPayConfigByID tests wx pay configuration by id

  Test WxPay configuration in payment merchant config. Reference: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1">WxPay Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test WxPay config</li></ul>
*/
func (a *Client) TestWxPayConfigByID(params *TestWxPayConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestWxPayConfigByIDOK, *TestWxPayConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestWxPayConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testWxPayConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/wxpayconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestWxPayConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestWxPayConfigByIDOK:
		return v, nil, nil
	case *TestWxPayConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestXsollaConfig tests xsolla configuration

  Check xsolla configuration, Reference: <a href="https://developers.xsolla.com/?#simple-checkout">Xsolla Document</a>.<h4>Check List:</h4> <ul><li>merchantId</li><li>projectId</li><li>apiKey</li></ul><h4>Non-check list:</h4><ul><li>projectSecretKey</li></ul>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: test result</li></ul>
*/
func (a *Client) TestXsollaConfig(params *TestXsollaConfigParams, authInfo runtime.ClientAuthInfoWriter) (*TestXsollaConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestXsollaConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testXsollaConfig",
		Method:             "POST",
		PathPattern:        "/admin/payment/config/merchant/xsollaconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestXsollaConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *TestXsollaConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TestXsollaConfigByID tests xsolla configuration by id

  Test xsolla configuration in payment merchant config. Reference: <a href="https://developers.xsolla.com/?#simple-checkout">Xsolla Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=2 (READ)</li><li><i>Returns</i>: test xsolla config</li></ul>
*/
func (a *Client) TestXsollaConfigByID(params *TestXsollaConfigByIDParams, authInfo runtime.ClientAuthInfoWriter) (*TestXsollaConfigByIDOK, *TestXsollaConfigByIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestXsollaConfigByIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testXsollaConfigById",
		Method:             "GET",
		PathPattern:        "/admin/payment/config/merchant/{id}/xsollaconfig/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TestXsollaConfigByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *TestXsollaConfigByIDOK:
		return v, nil, nil
	case *TestXsollaConfigByIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateAdyenConfig updates adyen config

  Update adyen config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateAdyenConfig(params *UpdateAdyenConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAdyenConfigOK, *UpdateAdyenConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAdyenConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateAdyenConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/adyenconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAdyenConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateAdyenConfigOK:
		return v, nil, nil
	case *UpdateAdyenConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateAliPayConfig updates alipay configuration

  Update alipay configuration.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateAliPayConfig(params *UpdateAliPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAliPayConfigOK, *UpdateAliPayConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAliPayConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateAliPayConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/alipayconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAliPayConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateAliPayConfigOK:
		return v, nil, nil
	case *UpdateAliPayConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateCheckoutConfig updates checkout com config

  Update checkout.com config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateCheckoutConfig(params *UpdateCheckoutConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateCheckoutConfigOK, *UpdateCheckoutConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCheckoutConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateCheckoutConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/checkoutconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateCheckoutConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateCheckoutConfigOK:
		return v, nil, nil
	case *UpdateCheckoutConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdatePayPalConfig updates pay pal config

  Update PayPal config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdatePayPalConfig(params *UpdatePayPalConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePayPalConfigOK, *UpdatePayPalConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePayPalConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updatePayPalConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/paypalconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePayPalConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdatePayPalConfigOK:
		return v, nil, nil
	case *UpdatePayPalConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdatePaymentProviderConfig updates payment provider config

  Update payment provider config.<br><pre><p><strong>Request Body Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>namespace</td><td>String</td><td>Yes</td><td>namespace, * indicates all namespace</td></tr><tr><td>region</td><td>String</td><td>Yes</td><td>region, * indicates all regions</td></tr><tr><td>aggregate</td><td>String</td><td>No</td><td>aggregate payment provider, such as XSOLLA, ADYEN, STRIPE</td></tr><tr><td>specials</td><td>List</td><td>No</td><td>special payment provider, such as ALIPAY, WXPAY</td></tr></table></pre>payment provider applied has priority: <ol><li>namespace and region match</li><li>namespace matches and region is *</li><li>region matches and namespace is *</li><li>namespace and region are *</li></ol>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: payment provider config</li></ul>
*/
func (a *Client) UpdatePaymentProviderConfig(params *UpdatePaymentProviderConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePaymentProviderConfigOK, *UpdatePaymentProviderConfigBadRequest, *UpdatePaymentProviderConfigNotFound, *UpdatePaymentProviderConfigConflict, *UpdatePaymentProviderConfigUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePaymentProviderConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updatePaymentProviderConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/provider/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePaymentProviderConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdatePaymentProviderConfigOK:
		return v, nil, nil, nil, nil, nil
	case *UpdatePaymentProviderConfigBadRequest:
		return nil, v, nil, nil, nil, nil
	case *UpdatePaymentProviderConfigNotFound:
		return nil, nil, v, nil, nil, nil
	case *UpdatePaymentProviderConfigConflict:
		return nil, nil, nil, v, nil, nil
	case *UpdatePaymentProviderConfigUnprocessableEntity:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdatePaymentTaxConfig updates payment global tax config

  Update payment tax config.<br><pre><p><strong>Request Body Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>taxJarEnabled</td><td>Boolean</td><td>false</td></tr><tr><td>taxJarApiToken</td><td>String</td><td>false</td><td>required, when taxJarEnabled is true and there is no existing token</td></tr><tr><td>sandboxTaxJarApiToken</td><td>String</td><td>false</td><td>optional</td></tr><tr><td>taxJarProductCodesMapping</td><td>Map</td><td>No</td><td>kye is item type and value is Product tax code, currently support those item types: APP, COINS, INGAMEITEM, BUNDLE, CODE, SUBSCRIPTION</td></tr></table></pre></ol>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: payment global tax config</li></ul>
*/
func (a *Client) UpdatePaymentTaxConfig(params *UpdatePaymentTaxConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePaymentTaxConfigOK, *UpdatePaymentTaxConfigBadRequest, *UpdatePaymentTaxConfigUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePaymentTaxConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updatePaymentTaxConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/tax",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePaymentTaxConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdatePaymentTaxConfigOK:
		return v, nil, nil, nil
	case *UpdatePaymentTaxConfigBadRequest:
		return nil, v, nil, nil
	case *UpdatePaymentTaxConfigUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateStripeConfig updates stripe config

  Update stripe config.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateStripeConfig(params *UpdateStripeConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateStripeConfigOK, *UpdateStripeConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateStripeConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateStripeConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/stripeconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateStripeConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateStripeConfigOK:
		return v, nil, nil
	case *UpdateStripeConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateWxPayConfig updates wxpay configuration

  Update wxpay configuration.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateWxPayConfig(params *UpdateWxPayConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateWxPayConfigOK, *UpdateWxPayConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateWxPayConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateWxPayConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/wxpayconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateWxPayConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateWxPayConfigOK:
		return v, nil, nil
	case *UpdateWxPayConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateWxPayConfigCert uploads wxpay cert file

  Upload wxpay cert file.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateWxPayConfigCert(params *UpdateWxPayConfigCertParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateWxPayConfigCertOK, *UpdateWxPayConfigCertNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateWxPayConfigCertParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateWxPayConfigCert",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/wxpayconfig/cert",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateWxPayConfigCertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateWxPayConfigCertOK:
		return v, nil, nil
	case *UpdateWxPayConfigCertNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateXsollaConfig updates xsolla configuration

  Update xsolla configuration. Reference: <a href="https://developers.xsolla.com/?#simple-checkout">Xsolla Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateXsollaConfig(params *UpdateXsollaConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateXsollaConfigOK, *UpdateXsollaConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateXsollaConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateXsollaConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/xsollaconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateXsollaConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateXsollaConfigOK:
		return v, nil, nil
	case *UpdateXsollaConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateXsollaUIConfig updates xsolla UI configuration

  Update xsolla UI configuration.Reference: <a href="https://developers.xsolla.com/api.html#ui-integrations">Xsolla Document</a>.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:PAYMENT:CONFIG", action=4 (UPDATE)</li><li><i>Returns</i>: updated payment merchant config</li></ul>
*/
func (a *Client) UpdateXsollaUIConfig(params *UpdateXsollaUIConfigParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateXsollaUIConfigOK, *UpdateXsollaUIConfigNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateXsollaUIConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateXsollaUIConfig",
		Method:             "PUT",
		PathPattern:        "/admin/payment/config/merchant/{id}/xsollauiconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateXsollaUIConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateXsollaUIConfigOK:
		return v, nil, nil
	case *UpdateXsollaUIConfigNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
