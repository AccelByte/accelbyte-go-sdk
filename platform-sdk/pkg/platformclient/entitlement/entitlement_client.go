// Code generated by go-swagger; DO NOT EDIT.

package entitlement

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new entitlement API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for entitlement API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	ConsumeUserEntitlement(params *ConsumeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*ConsumeUserEntitlementOK, *ConsumeUserEntitlementNotFound, *ConsumeUserEntitlementConflict, error)

	CreateUserDistributionReceiver(params *CreateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*CreateUserDistributionReceiverCreated, *CreateUserDistributionReceiverConflict, error)

	DeleteUserDistributionReceiver(params *DeleteUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserDistributionReceiverNoContent, *DeleteUserDistributionReceiverNotFound, error)

	DisableUserEntitlement(params *DisableUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*DisableUserEntitlementOK, *DisableUserEntitlementNotFound, *DisableUserEntitlementConflict, error)

	EnableUserEntitlement(params *EnableUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*EnableUserEntitlementOK, *EnableUserEntitlementNotFound, *EnableUserEntitlementConflict, error)

	ExistsAnyUserActiveEntitlement(params *ExistsAnyUserActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*ExistsAnyUserActiveEntitlementOK, error)

	ExistsAnyUserActiveEntitlementByItemIds(params *ExistsAnyUserActiveEntitlementByItemIdsParams, authInfo runtime.ClientAuthInfoWriter) (*ExistsAnyUserActiveEntitlementByItemIdsOK, error)

	GetEntitlement(params *GetEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GetEntitlementOK, *GetEntitlementNotFound, error)

	GetUserAppEntitlementByAppID(params *GetUserAppEntitlementByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserAppEntitlementByAppIDOK, *GetUserAppEntitlementByAppIDNotFound, error)

	GetUserAppEntitlementOwnershipByAppID(params *GetUserAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserAppEntitlementOwnershipByAppIDOK, error)

	GetUserDistributionReceivers(params *GetUserDistributionReceiversParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserDistributionReceiversOK, *GetUserDistributionReceiversBadRequest, error)

	GetUserEntitlement(params *GetUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOK, *GetUserEntitlementNotFound, error)

	GetUserEntitlementByItemID(params *GetUserEntitlementByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementByItemIDOK, *GetUserEntitlementByItemIDNotFound, error)

	GetUserEntitlementBySku(params *GetUserEntitlementBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementBySkuOK, *GetUserEntitlementBySkuNotFound, error)

	GetUserEntitlementHistories(params *GetUserEntitlementHistoriesParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementHistoriesOK, error)

	GetUserEntitlementOwnershipByItemID(params *GetUserEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOwnershipByItemIDOK, error)

	GetUserEntitlementOwnershipBySku(params *GetUserEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOwnershipBySkuOK, error)

	GrantUserEntitlement(params *GrantUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GrantUserEntitlementCreated, *GrantUserEntitlementNotFound, *GrantUserEntitlementUnprocessableEntity, error)

	PublicConsumeUserEntitlement(params *PublicConsumeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicConsumeUserEntitlementOK, *PublicConsumeUserEntitlementNotFound, *PublicConsumeUserEntitlementConflict, error)

	PublicCreateUserDistributionReceiver(params *PublicCreateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicCreateUserDistributionReceiverCreated, *PublicCreateUserDistributionReceiverConflict, error)

	PublicDeleteUserDistributionReceiver(params *PublicDeleteUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicDeleteUserDistributionReceiverNoContent, *PublicDeleteUserDistributionReceiverNotFound, error)

	PublicDistributeUserDistribution(params *PublicDistributeUserDistributionParams, authInfo runtime.ClientAuthInfoWriter) (*PublicDistributeUserDistributionOK, *PublicDistributeUserDistributionBadRequest, *PublicDistributeUserDistributionNotFound, error)

	PublicExistsAnyMyActiveEntitlement(params *PublicExistsAnyMyActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicExistsAnyMyActiveEntitlementOK, error)

	PublicExistsAnyUserActiveEntitlement(params *PublicExistsAnyUserActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicExistsAnyUserActiveEntitlementOK, error)

	PublicGetEntitlementOwnershipToken(params *PublicGetEntitlementOwnershipTokenParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetEntitlementOwnershipTokenOK, error)

	PublicGetMyAppEntitlementOwnershipByAppID(params *PublicGetMyAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyAppEntitlementOwnershipByAppIDOK, error)

	PublicGetMyEntitlementOwnershipByItemID(params *PublicGetMyEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyEntitlementOwnershipByItemIDOK, error)

	PublicGetMyEntitlementOwnershipBySku(params *PublicGetMyEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyEntitlementOwnershipBySkuOK, error)

	PublicGetUserAppEntitlementByAppID(params *PublicGetUserAppEntitlementByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserAppEntitlementByAppIDOK, *PublicGetUserAppEntitlementByAppIDNotFound, error)

	PublicGetUserAppEntitlementOwnershipByAppID(params *PublicGetUserAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserAppEntitlementOwnershipByAppIDOK, error)

	PublicGetUserDistributionReceivers(params *PublicGetUserDistributionReceiversParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserDistributionReceiversOK, *PublicGetUserDistributionReceiversBadRequest, *PublicGetUserDistributionReceiversNotFound, error)

	PublicGetUserEntitlement(params *PublicGetUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOK, *PublicGetUserEntitlementNotFound, error)

	PublicGetUserEntitlementByItemID(params *PublicGetUserEntitlementByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementByItemIDOK, *PublicGetUserEntitlementByItemIDNotFound, error)

	PublicGetUserEntitlementBySku(params *PublicGetUserEntitlementBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementBySkuOK, *PublicGetUserEntitlementBySkuNotFound, error)

	PublicGetUserEntitlementOwnershipByItemID(params *PublicGetUserEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOwnershipByItemIDOK, error)

	PublicGetUserEntitlementOwnershipBySku(params *PublicGetUserEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOwnershipBySkuOK, error)

	PublicQueryUserEntitlements(params *PublicQueryUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryUserEntitlementsOK, error)

	PublicQueryUserEntitlementsByAppType(params *PublicQueryUserEntitlementsByAppTypeParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryUserEntitlementsByAppTypeOK, error)

	PublicUpdateUserDistributionReceiver(params *PublicUpdateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicUpdateUserDistributionReceiverNoContent, error)

	QueryEntitlements(params *QueryEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryEntitlementsOK, error)

	QueryUserEntitlements(params *QueryUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUserEntitlementsOK, error)

	QueryUserEntitlementsByAppType(params *QueryUserEntitlementsByAppTypeParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUserEntitlementsByAppTypeOK, error)

	RevokeUserEntitlement(params *RevokeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*RevokeUserEntitlementOK, *RevokeUserEntitlementNotFound, error)

	RevokeUserEntitlements(params *RevokeUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*RevokeUserEntitlementsOK, error)

	UpdateUserDistributionReceiver(params *UpdateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateUserDistributionReceiverNoContent, error)

	UpdateUserEntitlement(params *UpdateUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateUserEntitlementOK, *UpdateUserEntitlementNotFound, *UpdateUserEntitlementConflict, *UpdateUserEntitlementUnprocessableEntity, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  ConsumeUserEntitlement consumes user entitlement

  Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: consumed entitlement</li></ul>
*/
func (a *Client) ConsumeUserEntitlement(params *ConsumeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*ConsumeUserEntitlementOK, *ConsumeUserEntitlementNotFound, *ConsumeUserEntitlementConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConsumeUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "consumeUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ConsumeUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ConsumeUserEntitlementOK:
		return v, nil, nil, nil
	case *ConsumeUserEntitlementNotFound:
		return nil, v, nil, nil
	case *ConsumeUserEntitlementConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateUserDistributionReceiver creates distribution receiver

  Create distribution receiver for a specific user by dedicated server. Once user distribution receiver created, user can distribute distribution to receiver.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=1 (CREATE)</li></ul>
*/
func (a *Client) CreateUserDistributionReceiver(params *CreateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*CreateUserDistributionReceiverCreated, *CreateUserDistributionReceiverConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createUserDistributionReceiver",
		Method:             "POST",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *CreateUserDistributionReceiverCreated:
		return v, nil, nil
	case *CreateUserDistributionReceiverConflict:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteUserDistributionReceiver deletes distribution receiver

  Delete a distribution receiver for a specific user by dedicated server.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=8 (DELETE)</li></ul>
*/
func (a *Client) DeleteUserDistributionReceiver(params *DeleteUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserDistributionReceiverNoContent, *DeleteUserDistributionReceiverNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteUserDistributionReceiver",
		Method:             "DELETE",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteUserDistributionReceiverNoContent:
		return v, nil, nil
	case *DeleteUserDistributionReceiverNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DisableUserEntitlement disables user entitlement

  Disable user entitlement if entitlement, only active entitlement can be disable, disabled entitlement can't consume/distribute.<br><b>Like revoke, it will lose the entitlement ownership, except disabled entitlement can enable.</b><br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: disable entitlement</li></ul>
*/
func (a *Client) DisableUserEntitlement(params *DisableUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*DisableUserEntitlementOK, *DisableUserEntitlementNotFound, *DisableUserEntitlementConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisableUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "disableUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/disable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DisableUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DisableUserEntitlementOK:
		return v, nil, nil, nil
	case *DisableUserEntitlementNotFound:
		return nil, v, nil, nil
	case *DisableUserEntitlementConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  EnableUserEntitlement enables user entitlement

  Enable user entitlement.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: enable entitlement</li></ul>
*/
func (a *Client) EnableUserEntitlement(params *EnableUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*EnableUserEntitlementOK, *EnableUserEntitlementNotFound, *EnableUserEntitlementConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/enable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *EnableUserEntitlementOK:
		return v, nil, nil, nil
	case *EnableUserEntitlementNotFound:
		return nil, v, nil, nil
	case *EnableUserEntitlementConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ExistsAnyUserActiveEntitlement exists any user active entitlement

  Exists any user active entitlement of specified itemIds, skus and appIds<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) ExistsAnyUserActiveEntitlement(params *ExistsAnyUserActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*ExistsAnyUserActiveEntitlementOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExistsAnyUserActiveEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "existsAnyUserActiveEntitlement",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/any",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExistsAnyUserActiveEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *ExistsAnyUserActiveEntitlementOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ExistsAnyUserActiveEntitlementByItemIds exists any user active entitlement

  Exists any user active entitlement of specified items.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) ExistsAnyUserActiveEntitlementByItemIds(params *ExistsAnyUserActiveEntitlementByItemIdsParams, authInfo runtime.ClientAuthInfoWriter) (*ExistsAnyUserActiveEntitlementByItemIdsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExistsAnyUserActiveEntitlementByItemIdsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "existsAnyUserActiveEntitlementByItemIds",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/anyOf",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExistsAnyUserActiveEntitlementByItemIdsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *ExistsAnyUserActiveEntitlementByItemIdsOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetEntitlement gets entitlement

  Get entitlement.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement</li></ul>
*/
func (a *Client) GetEntitlement(params *GetEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GetEntitlementOK, *GetEntitlementNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEntitlement",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/entitlements/{entitlementId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetEntitlementOK:
		return v, nil, nil
	case *GetEntitlementNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserAppEntitlementByAppID gets user app entitlement by app Id

  Get user app entitlement by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserAppEntitlementByAppID(params *GetUserAppEntitlementByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserAppEntitlementByAppIDOK, *GetUserAppEntitlementByAppIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserAppEntitlementByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserAppEntitlementByAppId",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserAppEntitlementByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetUserAppEntitlementByAppIDOK:
		return v, nil, nil
	case *GetUserAppEntitlementByAppIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserAppEntitlementOwnershipByAppID gets user app entitlement ownership by app Id

  Get user app entitlement ownership by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserAppEntitlementOwnershipByAppID(params *GetUserAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserAppEntitlementOwnershipByAppIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserAppEntitlementOwnershipByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserAppEntitlementOwnershipByAppId",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserAppEntitlementOwnershipByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetUserAppEntitlementOwnershipByAppIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserDistributionReceivers gets distribution receivers

  Get distribution receivers for a specific game user by dedicated server.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=2 (READ)</li><li><i>Returns</i>: distribution receiver info list</li></ul>
*/
func (a *Client) GetUserDistributionReceivers(params *GetUserDistributionReceiversParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserDistributionReceiversOK, *GetUserDistributionReceiversBadRequest, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserDistributionReceiversParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserDistributionReceivers",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/receivers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserDistributionReceiversReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetUserDistributionReceiversOK:
		return v, nil, nil
	case *GetUserDistributionReceiversBadRequest:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlement gets user entitlement

  Get user entitlement.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement</li></ul>
*/
func (a *Client) GetUserEntitlement(params *GetUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOK, *GetUserEntitlementNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlement",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementOK:
		return v, nil, nil
	case *GetUserEntitlementNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlementByItemID gets user entitlement by item Id

  Get user entitlement by itemId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserEntitlementByItemID(params *GetUserEntitlementByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementByItemIDOK, *GetUserEntitlementByItemIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementByItemIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlementByItemId",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/byItemId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementByItemIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementByItemIDOK:
		return v, nil, nil
	case *GetUserEntitlementByItemIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlementBySku gets user entitlement by sku

  Get user entitlement by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserEntitlementBySku(params *GetUserEntitlementBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementBySkuOK, *GetUserEntitlementBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlementBySku",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementBySkuOK:
		return v, nil, nil
	case *GetUserEntitlementBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlementHistories gets user entitlement history

  Get user entitlement histories.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: list of entitlement history</li></ul>
*/
func (a *Client) GetUserEntitlementHistories(params *GetUserEntitlementHistoriesParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementHistoriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementHistoriesParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlementHistories",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementHistoriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementHistoriesOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlementOwnershipByItemID gets user entitlement ownership by item Id

  Get user entitlement ownership by itemId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserEntitlementOwnershipByItemID(params *GetUserEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOwnershipByItemIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementOwnershipByItemIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlementOwnershipByItemId",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementOwnershipByItemIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementOwnershipByItemIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetUserEntitlementOwnershipBySku gets user entitlement ownership by sku

  Get user entitlement ownership by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) GetUserEntitlementOwnershipBySku(params *GetUserEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserEntitlementOwnershipBySkuOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserEntitlementOwnershipBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserEntitlementOwnershipBySku",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserEntitlementOwnershipBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetUserEntitlementOwnershipBySkuOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GrantUserEntitlement grants user entitlement

  Grant user entitlement.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=1 (CREATE)</li><li><i>Returns</i>: granted entitlement</li></ul>
*/
func (a *Client) GrantUserEntitlement(params *GrantUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*GrantUserEntitlementCreated, *GrantUserEntitlementNotFound, *GrantUserEntitlementUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGrantUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "grantUserEntitlement",
		Method:             "POST",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GrantUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GrantUserEntitlementCreated:
		return v, nil, nil, nil
	case *GrantUserEntitlementNotFound:
		return nil, v, nil, nil
	case *GrantUserEntitlementUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicConsumeUserEntitlement consumes user entitlement

  Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.<br>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: consumed entitlement</li></ul>
*/
func (a *Client) PublicConsumeUserEntitlement(params *PublicConsumeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicConsumeUserEntitlementOK, *PublicConsumeUserEntitlementNotFound, *PublicConsumeUserEntitlementConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicConsumeUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicConsumeUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicConsumeUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicConsumeUserEntitlementOK:
		return v, nil, nil, nil
	case *PublicConsumeUserEntitlementNotFound:
		return nil, v, nil, nil
	case *PublicConsumeUserEntitlementConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicCreateUserDistributionReceiver creates user distribution receiver

  Create distribution receiver for a specific user. Once user distribution receiver created, user can distribute distribution to receiver.<br>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=1 (CREATE)</li></ul>
*/
func (a *Client) PublicCreateUserDistributionReceiver(params *PublicCreateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicCreateUserDistributionReceiverCreated, *PublicCreateUserDistributionReceiverConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicCreateUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicCreateUserDistributionReceiver",
		Method:             "POST",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicCreateUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicCreateUserDistributionReceiverCreated:
		return v, nil, nil
	case *PublicCreateUserDistributionReceiverConflict:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicDeleteUserDistributionReceiver deletes a user distribution receiver

  Delete a distribution receiver for a specific user.<br>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=8 (DELETE)</li></ul>
*/
func (a *Client) PublicDeleteUserDistributionReceiver(params *PublicDeleteUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicDeleteUserDistributionReceiverNoContent, *PublicDeleteUserDistributionReceiverNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicDeleteUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicDeleteUserDistributionReceiver",
		Method:             "DELETE",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicDeleteUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicDeleteUserDistributionReceiverNoContent:
		return v, nil, nil
	case *PublicDeleteUserDistributionReceiverNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicDistributeUserDistribution distributes my distribution

  Distribute my distribution with my user credentials. After successfully distributed, a notification will be send to configured web hook<br><p><strong>Notification Body:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Description</td></tr><tr><td>payload</td><td>String</td><td>Business object in compact json string </td></tr><tr><td>sign</td><td>String</td><td>Sha1 hex signature for payload and private key</td></tr></table><p><strong>Notification Body Example:</strong></p><pre><code style='overflow: auto'>{
       "payload":"{
           \"namespace\": \"publisherNamespace\",
           \"targetNamespace\": \"game1\",
           \"targetUserId\": \"94451623768940d58416ca33ca767ec3\",
           \"issuedAt\": \"2018-07-26T07:11:16.547Z\",
           \"type\": \"distribution\",
           \"extUserId\": \"1234abcd\",
           \"sku\": \"1234asdf\",
           \"quantity\": 1,
           \"nonceStr\": \"34c1dcf3eb58455eb161465bbfc0b590\"
       }",
       "sign":"e31fb92516cc9faaf50ad70343e1293acec6f3d5"
}</pre></code></pre></code><p><strong>Payload Parameters:</strong></p><pre><table><tr><td>Parameter</td><td>Type</td><td>Description</td></tr><tr><td>namespace</td><td>String</td><td>The publisher namespace</td></tr><tr><td>targetNamespace</td><td>String</td><td>The target game namespace</td></tr><tr><td>targetUserId</td><td>String</td><td>The user id in target game namespace</td></tr><tr><td>issuedAt</td><td>String</td><td>Issue time</td></tr><tr><td>type</td><td>String</td><td>Notification type, it is a fixed value 'distribution'</td></tr><tr><td>extUserId</td><td>String</td><td>Unique identity, e.g. character id</td></tr><tr><td>sku</td><td>String</td><td>Item unique identity</td></tr><tr><td>quantity</td><td>Integer</td><td>quantity</td></tr><tr><td>nonceStr</td><td>String</td><td>Random string, max length is 32, can be timestamp or uuid</td></tr></table></pre><h4>Encryption Rule:</h4><p>Concat payload json string and private key and then do sha1Hex.</p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=4 (UPDATE)</li></ul>
*/
func (a *Client) PublicDistributeUserDistribution(params *PublicDistributeUserDistributionParams, authInfo runtime.ClientAuthInfoWriter) (*PublicDistributeUserDistributionOK, *PublicDistributeUserDistributionBadRequest, *PublicDistributeUserDistributionNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicDistributeUserDistributionParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicDistributeUserDistribution",
		Method:             "PUT",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/distribute",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicDistributeUserDistributionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicDistributeUserDistributionOK:
		return v, nil, nil, nil
	case *PublicDistributeUserDistributionBadRequest:
		return nil, v, nil, nil
	case *PublicDistributeUserDistributionNotFound:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicExistsAnyMyActiveEntitlement exists any my active entitlement

  Exists any my active entitlement of specified itemIds, skus and appIds<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicExistsAnyMyActiveEntitlement(params *PublicExistsAnyMyActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicExistsAnyMyActiveEntitlementOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicExistsAnyMyActiveEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicExistsAnyMyActiveEntitlement",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/me/entitlements/ownership/any",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicExistsAnyMyActiveEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicExistsAnyMyActiveEntitlementOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicExistsAnyUserActiveEntitlement exists any user active entitlement

  Exists any user active entitlement of specified itemIds, skus and appIds<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicExistsAnyUserActiveEntitlement(params *PublicExistsAnyUserActiveEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicExistsAnyUserActiveEntitlementOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicExistsAnyUserActiveEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicExistsAnyUserActiveEntitlement",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/any",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicExistsAnyUserActiveEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicExistsAnyUserActiveEntitlementOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetEntitlementOwnershipToken gets an entitlement ownership token

  Gets an entitlement ownership token of specified itemIds, skus and appIds<p>The decoded ownership token header like below:<p><pre><code>{
  "kid": "9fd4cd5f991cebe3323605cd12d3b8bfdfc73fa4",
  "typ": "JWT",
  "alg": "RS256"
}
</code></pre>That you can get the jwks by api <baseUrl>/platform/jwks, if the configured private key is same as IAM, <p>you can also get jwks from IAM endpoint. <p>The decoded ownership token payload like below:<p><pre><code>{
 "namespace": "accelbyte",
 "entitlements": [
  {
    "itemId": "4c1296291f604c199f7bb7f0ee02e5f8",
    "appType": null,
    "appId": null,
    "namespace": "accelbyte",
    "itemNamespace": "accelbyte",
    "sku": "prime-plus"
  },
  {
    "itemId": "e8f4974cf45c4e1f8d4f0c6990c518bd",
    "appType": "GAME",
    "appId": "omeganebula",
    "namespace": "accelbyte",
    "itemNamespace": "accelbyte",
    "sku": "APPG005ON"
  }
 ],
"sub": "66459eb6a4e44e6fb0040bd20c1079a5",
"exp": 1619624360,
"iat": 1619624060
}
</code></pre><b>if there's no active entitlement for the specific params, the entitlements section will be omitted</b>.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetEntitlementOwnershipToken(params *PublicGetEntitlementOwnershipTokenParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetEntitlementOwnershipTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetEntitlementOwnershipTokenParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetEntitlementOwnershipToken",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/me/entitlements/ownershipToken",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetEntitlementOwnershipTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetEntitlementOwnershipTokenOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetMyAppEntitlementOwnershipByAppID gets my app entitlement ownership by app Id

  Get my app entitlement ownership by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li><li><i>Path's namespace</i> : <ul><li>can be filled with <b>publisher namespace</b> in order to get <b>publisher namespace app entitlement ownership</b></li></ul></li></ul>
*/
func (a *Client) PublicGetMyAppEntitlementOwnershipByAppID(params *PublicGetMyAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyAppEntitlementOwnershipByAppIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetMyAppEntitlementOwnershipByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetMyAppEntitlementOwnershipByAppId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/me/entitlements/ownership/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetMyAppEntitlementOwnershipByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetMyAppEntitlementOwnershipByAppIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetMyEntitlementOwnershipByItemID gets my entitlement ownership by item Id

  Get my entitlement ownership by itemId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li><li><i>Path's namespace</i> : <ul><li>can be filled with <b>publisher namespace</b> in order to get <b>publisher namespace entitlement ownership by sku</b></li><li>can be filled with <b>game namespace</b> in order to get <b>game namespace entitlement ownership by sku</b></li></ul></li></ul>
*/
func (a *Client) PublicGetMyEntitlementOwnershipByItemID(params *PublicGetMyEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyEntitlementOwnershipByItemIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetMyEntitlementOwnershipByItemIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetMyEntitlementOwnershipByItemId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/me/entitlements/ownership/byItemId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetMyEntitlementOwnershipByItemIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetMyEntitlementOwnershipByItemIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetMyEntitlementOwnershipBySku gets my entitlement ownership by sku

  Get my entitlement ownership by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li><li><i>Path's namespace</i> : <ul><li>can be filled with <b>publisher namespace</b> in order to get <b>publisher namespace entitlement ownership by sku</b></li><li>can be filled with <b>game namespace</b> in order to get <b>game namespace entitlement ownership by sku</b></li></ul></li></ul>
*/
func (a *Client) PublicGetMyEntitlementOwnershipBySku(params *PublicGetMyEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetMyEntitlementOwnershipBySkuOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetMyEntitlementOwnershipBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetMyEntitlementOwnershipBySku",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/me/entitlements/ownership/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetMyEntitlementOwnershipBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetMyEntitlementOwnershipBySkuOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserAppEntitlementByAppID gets user app entitlement by app Id

  Get user app entitlement by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserAppEntitlementByAppID(params *PublicGetUserAppEntitlementByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserAppEntitlementByAppIDOK, *PublicGetUserAppEntitlementByAppIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserAppEntitlementByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserAppEntitlementByAppId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserAppEntitlementByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserAppEntitlementByAppIDOK:
		return v, nil, nil
	case *PublicGetUserAppEntitlementByAppIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserAppEntitlementOwnershipByAppID gets user app entitlement ownership by app Id

  Get user app entitlement ownership by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserAppEntitlementOwnershipByAppID(params *PublicGetUserAppEntitlementOwnershipByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserAppEntitlementOwnershipByAppIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserAppEntitlementOwnershipByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserAppEntitlementOwnershipByAppId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserAppEntitlementOwnershipByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserAppEntitlementOwnershipByAppIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserDistributionReceivers gets distribution receivers

  Get distribution receivers in a specific namespace.<br>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=2 (READ)</li><li><i>Returns</i>: distribution receiver info list</li></ul>
*/
func (a *Client) PublicGetUserDistributionReceivers(params *PublicGetUserDistributionReceiversParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserDistributionReceiversOK, *PublicGetUserDistributionReceiversBadRequest, *PublicGetUserDistributionReceiversNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserDistributionReceiversParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserDistributionReceivers",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/receivers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserDistributionReceiversReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserDistributionReceiversOK:
		return v, nil, nil, nil
	case *PublicGetUserDistributionReceiversBadRequest:
		return nil, v, nil, nil
	case *PublicGetUserDistributionReceiversNotFound:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserEntitlement gets user entitlement

  Get user entitlement.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement</li></ul>
*/
func (a *Client) PublicGetUserEntitlement(params *PublicGetUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOK, *PublicGetUserEntitlementNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserEntitlement",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserEntitlementOK:
		return v, nil, nil
	case *PublicGetUserEntitlementNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserEntitlementByItemID gets user entitlement by item Id

  Get user entitlement by itemId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserEntitlementByItemID(params *PublicGetUserEntitlementByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementByItemIDOK, *PublicGetUserEntitlementByItemIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserEntitlementByItemIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserEntitlementByItemId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/byItemId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserEntitlementByItemIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserEntitlementByItemIDOK:
		return v, nil, nil
	case *PublicGetUserEntitlementByItemIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserEntitlementBySku gets user entitlement by sku

  Get user entitlement by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserEntitlementBySku(params *PublicGetUserEntitlementBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementBySkuOK, *PublicGetUserEntitlementBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserEntitlementBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserEntitlementBySku",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserEntitlementBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserEntitlementBySkuOK:
		return v, nil, nil
	case *PublicGetUserEntitlementBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserEntitlementOwnershipByItemID gets user entitlement ownership by item Id

  Get user entitlement ownership by itemId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserEntitlementOwnershipByItemID(params *PublicGetUserEntitlementOwnershipByItemIDParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOwnershipByItemIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserEntitlementOwnershipByItemIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserEntitlementOwnershipByItemId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserEntitlementOwnershipByItemIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserEntitlementOwnershipByItemIDOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUserEntitlementOwnershipBySku gets user entitlement ownership by sku

  Get user entitlement ownership by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li></ul>
*/
func (a *Client) PublicGetUserEntitlementOwnershipBySku(params *PublicGetUserEntitlementOwnershipBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetUserEntitlementOwnershipBySkuOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUserEntitlementOwnershipBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUserEntitlementOwnershipBySku",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUserEntitlementOwnershipBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetUserEntitlementOwnershipBySkuOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicQueryUserEntitlements queries user entitlements

  Query user entitlements for a specific user.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement list</li></ul>
*/
func (a *Client) PublicQueryUserEntitlements(params *PublicQueryUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryUserEntitlementsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryUserEntitlementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryUserEntitlements",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicQueryUserEntitlementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicQueryUserEntitlementsOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicQueryUserEntitlementsByAppType queries app entitlements by app type

  Query app entitlements by appType.<p>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: app entitlement pagination</li></ul>
*/
func (a *Client) PublicQueryUserEntitlementsByAppType(params *PublicQueryUserEntitlementsByAppTypeParams, authInfo runtime.ClientAuthInfoWriter) (*PublicQueryUserEntitlementsByAppTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryUserEntitlementsByAppTypeParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryUserEntitlementsByAppType",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/byAppType",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicQueryUserEntitlementsByAppTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicQueryUserEntitlementsByAppTypeOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicUpdateUserDistributionReceiver updates user distribution receiver

  Update distribution receiver for a specific user. It will create a new one if not exist.<br>Other detail info: <ul><li><i>Required permission</i>: resource="NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=4 (UPDATE)</li></ul>
*/
func (a *Client) PublicUpdateUserDistributionReceiver(params *PublicUpdateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*PublicUpdateUserDistributionReceiverNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicUpdateUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicUpdateUserDistributionReceiver",
		Method:             "PUT",
		PathPattern:        "/public/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicUpdateUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicUpdateUserDistributionReceiverNoContent:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryEntitlements queries entitlements

  Query entitlements.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement list</li></ul>
*/
func (a *Client) QueryEntitlements(params *QueryEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryEntitlementsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryEntitlementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryEntitlements",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/entitlements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryEntitlementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *QueryEntitlementsOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryUserEntitlements queries user entitlements

  Query entitlements for a specific user.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2 (READ)</li><li><i>Returns</i>: entitlement list</li></ul>
*/
func (a *Client) QueryUserEntitlements(params *QueryUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUserEntitlementsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryUserEntitlementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryUserEntitlements",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryUserEntitlementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *QueryUserEntitlementsOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryUserEntitlementsByAppType queries app entitlements by app type

  Query app entitlements by appType.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=2<li><i>Returns</i>: app entitlement pagination</li></ul>
*/
func (a *Client) QueryUserEntitlementsByAppType(params *QueryUserEntitlementsByAppTypeParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUserEntitlementsByAppTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryUserEntitlementsByAppTypeParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryUserEntitlementsByAppType",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppType",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryUserEntitlementsByAppTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *QueryUserEntitlementsByAppTypeOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  RevokeUserEntitlement revokes user entitlement

  Revoke user entitlement.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: revoke entitlement</li></ul>
*/
func (a *Client) RevokeUserEntitlement(params *RevokeUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*RevokeUserEntitlementOK, *RevokeUserEntitlementNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRevokeUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "revokeUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RevokeUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *RevokeUserEntitlementOK:
		return v, nil, nil
	case *RevokeUserEntitlementNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  RevokeUserEntitlements revokes user s entitlements by ids

  Revoke user's entitlements by ids.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: revoke entitlements count</li></ul>
*/
func (a *Client) RevokeUserEntitlements(params *RevokeUserEntitlementsParams, authInfo runtime.ClientAuthInfoWriter) (*RevokeUserEntitlementsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRevokeUserEntitlementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "revokeUserEntitlements",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/revoke/byIds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RevokeUserEntitlementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *RevokeUserEntitlementsOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateUserDistributionReceiver updates distribution receiver

  Update distribution receiver for a specific user by dedicated server. It will create a new one if not exists.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:DISTRIBUTION", action=4 (UPDATE)</li></ul>
*/
func (a *Client) UpdateUserDistributionReceiver(params *UpdateUserDistributionReceiverParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateUserDistributionReceiverNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateUserDistributionReceiverParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateUserDistributionReceiver",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/receivers/{extUserId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateUserDistributionReceiverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *UpdateUserDistributionReceiverNoContent:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateUserEntitlement updates user entitlement

  Update user entitlement. If update CONSUMABLE entitlement useCount to 0, the status will be CONSUMED, if update quantity of DISTRIBUTION, the status will be DISTRIBUTED.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:USER:{userId}:ENTITLEMENT", action=4 (UPDATE)</li><li><i>Returns</i>: updated entitlement</li></ul>
*/
func (a *Client) UpdateUserEntitlement(params *UpdateUserEntitlementParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateUserEntitlementOK, *UpdateUserEntitlementNotFound, *UpdateUserEntitlementConflict, *UpdateUserEntitlementUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateUserEntitlementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateUserEntitlement",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateUserEntitlementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateUserEntitlementOK:
		return v, nil, nil, nil, nil
	case *UpdateUserEntitlementNotFound:
		return nil, v, nil, nil, nil
	case *UpdateUserEntitlementConflict:
		return nil, nil, v, nil, nil
	case *UpdateUserEntitlementUnprocessableEntity:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
