// Code generated by go-swagger; DO NOT EDIT.

package payment_station

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new payment station API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for payment station API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	GetPaymentCustomization(params *GetPaymentCustomizationParams) (*GetPaymentCustomizationOK, error)

	GetPaymentPublicConfig(params *GetPaymentPublicConfigParams) (*GetPaymentPublicConfigOK, error)

	GetPaymentTaxValue(params *GetPaymentTaxValueParams) (*GetPaymentTaxValueOK, *GetPaymentTaxValueBadRequest, *GetPaymentTaxValueNotFound, error)

	Pay(params *PayParams) (*PayOK, *PayBadRequest, *PayNotFound, *PayConflict, error)

	PublicCheckPaymentOrderPaidStatus(params *PublicCheckPaymentOrderPaidStatusParams) (*PublicCheckPaymentOrderPaidStatusOK, *PublicCheckPaymentOrderPaidStatusNotFound, error)

	PublicGetPaymentMethods(params *PublicGetPaymentMethodsParams) (*PublicGetPaymentMethodsOK, *PublicGetPaymentMethodsNotFound, error)

	PublicGetPaymentURL(params *PublicGetPaymentURLParams) (*PublicGetPaymentURLOK, *PublicGetPaymentURLBadRequest, *PublicGetPaymentURLForbidden, *PublicGetPaymentURLNotFound, error)

	PublicGetQRCode(params *PublicGetQRCodeParams, writer io.Writer) (*PublicGetQRCodeOK, error)

	PublicGetUnpaidPaymentOrder(params *PublicGetUnpaidPaymentOrderParams) (*PublicGetUnpaidPaymentOrderOK, *PublicGetUnpaidPaymentOrderNotFound, *PublicGetUnpaidPaymentOrderConflict, error)

	PublicNormalizePaymentReturnURL(params *PublicNormalizePaymentReturnURLParams) (*PublicNormalizePaymentReturnURLNoContent, *PublicNormalizePaymentReturnURLTemporaryRedirect, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  GetPaymentCustomization gets payment provider customization

  Get payment provider customization, at current only Adyen provide customization.<br>Other detail info: <ul><li><i>Returns</i>: customization</li></ul>
*/
func (a *Client) GetPaymentCustomization(params *GetPaymentCustomizationParams) (*GetPaymentCustomizationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPaymentCustomizationParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPaymentCustomization",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/customization",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPaymentCustomizationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetPaymentCustomizationOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetPaymentPublicConfig gets payment provider public config

  Get payment provider public config, at current only Strip provide public config.<br>Other detail info: <ul><li><i>Returns</i>: Public config</li></ul>
*/
func (a *Client) GetPaymentPublicConfig(params *GetPaymentPublicConfigParams) (*GetPaymentPublicConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPaymentPublicConfigParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPaymentPublicConfig",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/publicconfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPaymentPublicConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetPaymentPublicConfigOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetPaymentTaxValue gets tax result of a payment order

  Check and get a payment order's should pay tax.<br>Other detail info: <ul><li><i>Returns</i>: tax result</li></ul>
*/
func (a *Client) GetPaymentTaxValue(params *GetPaymentTaxValueParams) (*GetPaymentTaxValueOK, *GetPaymentTaxValueBadRequest, *GetPaymentTaxValueNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPaymentTaxValueParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPaymentTaxValue",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/tax",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPaymentTaxValueReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetPaymentTaxValueOK:
		return v, nil, nil, nil
	case *GetPaymentTaxValueBadRequest:
		return nil, v, nil, nil
	case *GetPaymentTaxValueNotFound:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  Pay dos payment

  Do payment(For now, this only support checkout.com).<br>Other detail info: <ul><li><i>Returns</i>: Payment process result</li></ul>
*/
func (a *Client) Pay(params *PayParams) (*PayOK, *PayBadRequest, *PayNotFound, *PayConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPayParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "pay",
		Method:             "POST",
		PathPattern:        "/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/pay",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PayOK:
		return v, nil, nil, nil, nil
	case *PayBadRequest:
		return nil, v, nil, nil, nil
	case *PayNotFound:
		return nil, nil, v, nil, nil
	case *PayConflict:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicCheckPaymentOrderPaidStatus checks payment order paid status

  Check payment order paid status.<br>Other detail info: <ul><li><i>Returns</i>: Payment order paid result</li></ul>
*/
func (a *Client) PublicCheckPaymentOrderPaidStatus(params *PublicCheckPaymentOrderPaidStatusParams) (*PublicCheckPaymentOrderPaidStatusOK, *PublicCheckPaymentOrderPaidStatusNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicCheckPaymentOrderPaidStatusParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicCheckPaymentOrderPaidStatus",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicCheckPaymentOrderPaidStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicCheckPaymentOrderPaidStatusOK:
		return v, nil, nil
	case *PublicCheckPaymentOrderPaidStatusNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetPaymentMethods gets payment methods

  Get payment methods.<br>Other detail info: <ul><li><i>Returns</i>: Payment method list</li></ul>
*/
func (a *Client) PublicGetPaymentMethods(params *PublicGetPaymentMethodsParams) (*PublicGetPaymentMethodsOK, *PublicGetPaymentMethodsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetPaymentMethodsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetPaymentMethods",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/methods",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetPaymentMethodsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetPaymentMethodsOK:
		return v, nil, nil
	case *PublicGetPaymentMethodsNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetPaymentURL gets payment url

  Get payment url.<br>Other detail info: <ul><li><i>Returns</i>: Get payment link</li></ul>
*/
func (a *Client) PublicGetPaymentURL(params *PublicGetPaymentURLParams) (*PublicGetPaymentURLOK, *PublicGetPaymentURLBadRequest, *PublicGetPaymentURLForbidden, *PublicGetPaymentURLNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetPaymentURLParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetPaymentUrl",
		Method:             "POST",
		PathPattern:        "/public/namespaces/{namespace}/payment/link",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetPaymentURLReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetPaymentURLOK:
		return v, nil, nil, nil, nil
	case *PublicGetPaymentURLBadRequest:
		return nil, v, nil, nil, nil
	case *PublicGetPaymentURLForbidden:
		return nil, nil, v, nil, nil
	case *PublicGetPaymentURLNotFound:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetQRCode gets qrcode

  Get qrcode.<br>Other detail info: <ul><li><i>Returns</i>: QRCode image stream</li></ul>
*/
func (a *Client) PublicGetQRCode(params *PublicGetQRCodeParams, writer io.Writer) (*PublicGetQRCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetQRCodeParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetQRCode",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/qrcode",
		ProducesMediaTypes: []string{"image/png"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetQRCodeReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *PublicGetQRCodeOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetUnpaidPaymentOrder gets payment order info

  Get payment order info.<br>Other detail info: <ul><li><i>Returns</i>: Payment order details</li></ul>
*/
func (a *Client) PublicGetUnpaidPaymentOrder(params *PublicGetUnpaidPaymentOrderParams) (*PublicGetUnpaidPaymentOrderOK, *PublicGetUnpaidPaymentOrderNotFound, *PublicGetUnpaidPaymentOrderConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetUnpaidPaymentOrderParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetUnpaidPaymentOrder",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetUnpaidPaymentOrderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetUnpaidPaymentOrderOK:
		return v, nil, nil, nil
	case *PublicGetUnpaidPaymentOrderNotFound:
		return nil, v, nil, nil
	case *PublicGetUnpaidPaymentOrderConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicNormalizePaymentReturnURL normalizes payment return url

  Normalize payment return url for payment provider<br>Payment response: <table><tr><td>Field</td><td>Type</td><td>Required</td><td>Description</td></tr><tr><td>orderNo</td><td>String</td><td>Yes</td><td>order no</td></tr><tr><td>paymentStatus</td><td>String</td><td>Yes</td><td><ul><li>DONE: The payment was successfully completed.</li><li>CANCELLED: The payment was cancelled by the shopper before completion, or the shopper returned to the merchant's site before completing the transaction.</li><li>PENDING: Inform the shopper that you've received their order, and are waiting for the payment to be completed.

When the shopper has completed the payment you will receive a successful AUTHORISATION.</li><li>RECEIVED: Inform the shopper that you've received their order, and are waiting for the payment to clear.</li><li>UNKNOWN: An error occurred during the payment processing.</li><li>FAILED: Shopper paid failed because of various reasons.</li></ul></td></tr><tr><td>reason</td><td>String</td><td>No</td><td>payment status reason</td></tr></table>Other detail info: <ul><li><i>xsolla</i>: parameters 'user_id', 'foreinginvoice', 'invoice_id' and 'status' will be automatically added to the link</li><li><i>adyen</i>: https://docs.adyen.com/developers/checkout/web-sdk</li></ul>
*/
func (a *Client) PublicNormalizePaymentReturnURL(params *PublicNormalizePaymentReturnURLParams) (*PublicNormalizePaymentReturnURLNoContent, *PublicNormalizePaymentReturnURLTemporaryRedirect, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicNormalizePaymentReturnURLParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicNormalizePaymentReturnUrl",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/payment/returnurl",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicNormalizePaymentReturnURLReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicNormalizePaymentReturnURLNoContent:
		return v, nil, nil
	case *PublicNormalizePaymentReturnURLTemporaryRedirect:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
