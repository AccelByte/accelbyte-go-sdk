// Code generated by go-swagger; DO NOT EDIT.

package o_auth2_0

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new o auth2 0 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for o auth2 0 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AuthorizeV3(params *AuthorizeV3Params, authInfo runtime.ClientAuthInfoWriter) (*AuthorizeV3Found, error)

	TokenGrantV3(params *TokenGrantV3Params, authInfo runtime.ClientAuthInfoWriter) (*TokenGrantV3OK, *TokenGrantV3BadRequest, *TokenGrantV3Unauthorized, *TokenGrantV3Forbidden, error)

	TokenRevocationV3(params *TokenRevocationV3Params, authInfo runtime.ClientAuthInfoWriter) (*TokenRevocationV3OK, *TokenRevocationV3BadRequest, *TokenRevocationV3Unauthorized, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AuthorizeV3 os auth2 authorize API

  Initializes OAuth2.0 authorization code flow<br/>
<p>The endpoint stores authorization request and redirects to login page with the authorization request id.
	The user can then do the authentication on the login page.
	The user will be redirected back to the requesting client with authorization code if successfully authenticated.
</p>
<p>Only authorization code flow supported by this endpoint, implicit flow is not supported.</p>
<ul>
	<li><p><strong>Authorize success</strong>:
		redirects to login page with the following information: ?request_id={authorization_request_id}</p>
	</li>
	<li><p><strong>Authorize failure</strong>:
		redirects to the given redirect uri with the following information:
		?error={error_code}&error_description={error description}</p>
	</li>
</ul>
	<p>Following are the error code based on the specification:</p>
<ul>
	<li><p>invalid_request: The request is missing a required parameter,
		includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.</p>
	</li>
	<li><p>server_error:
		The authorization server encountered an unexpected condition that prevented it from fulfilling the request.</p>
	</li>
	<li><p>unauthorized_client: The client is not authorized to request a token using this method.</p></li>
	<li><p>access_denied: The resource owner or authorization server denied the request.</p></li>
	<li><p>invalid_scope: The requested scope is invalid, unknown, or malformed.</p></li>
	<li><p>unsupported_response_type: The authorization server does not support obtaining a token using this method.</p></li>
	<li><p>temporarily_unavailable: The authorization server is currently unable to handle the request
		due to a temporary overloading or maintenance of the server.</p>
	</li>
</ul>
	<p>Please refer to the RFC for more information about authorization code flow: https://tools.ietf.org/html/rfc6749#section-4.1</p><br>
	action code: 10701


*/
func (a *Client) AuthorizeV3(params *AuthorizeV3Params, authInfo runtime.ClientAuthInfoWriter) (*AuthorizeV3Found, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuthorizeV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthorizeV3",
		Method:             "GET",
		PathPattern:        "/iam/v3/oauth/authorize",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuthorizeV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AuthorizeV3Found:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TokenGrantV3 os auth2 access token generation endpoint

  <p>This endpoint supports grant type:</p><ol>
	 		<li>Grant Type == <code>authorization_code</code>:<br />
				&nbsp;&nbsp;&nbsp; It generates the user token by given the authorization
				code which generated in "/v3/oauth/auth" API response. It should also pass
				in the redirect_uri, which should be the same as generating the
				authorization code request.
			</li>
			<li>Grant Type == <code>refresh_token</code>:<br />
	 			&nbsp;&nbsp;&nbsp; Used to get a new access token for a valid refresh token.
			</li>
			<li>Grant Type == <code>client_credentials</code>:<br />
	 			&nbsp;&nbsp;&nbsp; It generates a token by checking the client credentials provided through Authorization header.
			</li></ol>
			<h2>Access Token Content</h2>
			<p>Following is the access token’s content:</p>
			<ul>
			<li>
				<p><strong>namespace</strong>. It is the namespace the token was generated from.</p>
			</li>
			<li>
				<p><strong>display_name</strong>. The display name of the sub. It is empty if the token is generated from the client credential</p>
			</li>
			<li>
				<p><strong>roles</strong>. The sub’s roles. It is empty if the token is generated from the client credential</p>
			</li>
			<li>
				<p><strong>namespace_roles</strong>. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace</p>
			</li>
			<li>
				<p><strong>permissions</strong>. The sub or aud’ permissions</p>
			</li>
			<li>
				<p><strong>bans</strong>. The sub’s list of bans. It is used by the IAM client for validating the token.</p>
			</li>
			<li>
				<p><strong>jflgs</strong>. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents:</p>
			<ul>
				<li><p>1: Email Address Verified</p></li>
				<li><p>2: Phone Number Verified</p></li>
				<li><p>4: Anonymous</p></li>
				<li><p>8: Suspicious Login</p></li>
			</ul>
			</li>
			<li>
				<p><strong>aud</strong>. The aud is the targeted resource server.</p>
			</li>
			<li>
				<p><strong>iat</strong>. The time the token issues at. It is in Epoch time format</p>
			</li>
			<li>
				<p><strong>exp</strong>. The time the token expires. It is in Epoch time format</p>
			</li>
			<li>
				<p><strong>client_id</strong>. The UserID. The sub is omitted if the token is generated from client credential</p>
			</li>
			<li>
				<p><strong>scope</strong>. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings</p>
			</li>
			</ul>
			<h2>Bans</h2>
			<p>The JWT contains user's active bans with its expiry date. List of ban types can be obtained from /bans.</p>
			<h2>Track Login History</h2>
			<p>This endpoint will track login history to detect suspicious login activity, please provide "device_id" (alphanumeric) in request header parameter otherwise we will set to "unknown".</p>
			<p>Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default"</p>
			<p>action code: 10703
*/
func (a *Client) TokenGrantV3(params *TokenGrantV3Params, authInfo runtime.ClientAuthInfoWriter) (*TokenGrantV3OK, *TokenGrantV3BadRequest, *TokenGrantV3Unauthorized, *TokenGrantV3Forbidden, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTokenGrantV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TokenGrantV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/oauth/token",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TokenGrantV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *TokenGrantV3OK:
		return v, nil, nil, nil, nil
	case *TokenGrantV3BadRequest:
		return nil, v, nil, nil, nil
	case *TokenGrantV3Unauthorized:
		return nil, nil, v, nil, nil
	case *TokenGrantV3Forbidden:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  TokenRevocationV3 os auth2 token revocation API

  <p>This endpoint revokes a token.</p>
					 <p>This endpoint requires authorized requests header with valid access token.</p><br>action code: 10706
*/
func (a *Client) TokenRevocationV3(params *TokenRevocationV3Params, authInfo runtime.ClientAuthInfoWriter) (*TokenRevocationV3OK, *TokenRevocationV3BadRequest, *TokenRevocationV3Unauthorized, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTokenRevocationV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TokenRevocationV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/oauth/revoke",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &TokenRevocationV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *TokenRevocationV3OK:
		return v, nil, nil, nil
	case *TokenRevocationV3BadRequest:
		return nil, v, nil, nil
	case *TokenRevocationV3Unauthorized:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
