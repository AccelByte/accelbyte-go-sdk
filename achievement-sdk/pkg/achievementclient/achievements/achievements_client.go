// Code generated by go-swagger; DO NOT EDIT.

package achievements

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new achievements API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for achievements API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AdminCreateNewAchievement(params *AdminCreateNewAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateNewAchievementCreated, *AdminCreateNewAchievementBadRequest, *AdminCreateNewAchievementUnauthorized, *AdminCreateNewAchievementInternalServerError, error)

	AdminDeleteAchievement(params *AdminDeleteAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteAchievementNoContent, *AdminDeleteAchievementBadRequest, *AdminDeleteAchievementUnauthorized, *AdminDeleteAchievementNotFound, *AdminDeleteAchievementInternalServerError, error)

	AdminGetAchievement(params *AdminGetAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminGetAchievementOK, *AdminGetAchievementBadRequest, *AdminGetAchievementUnauthorized, *AdminGetAchievementNotFound, *AdminGetAchievementInternalServerError, error)

	AdminListAchievements(params *AdminListAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminListAchievementsOK, *AdminListAchievementsBadRequest, *AdminListAchievementsUnauthorized, *AdminListAchievementsNotFound, *AdminListAchievementsInternalServerError, error)

	AdminListUserAchievements(params *AdminListUserAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminListUserAchievementsOK, *AdminListUserAchievementsBadRequest, *AdminListUserAchievementsUnauthorized, *AdminListUserAchievementsNotFound, *AdminListUserAchievementsInternalServerError, error)

	AdminUnlockAchievement(params *AdminUnlockAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUnlockAchievementNoContent, *AdminUnlockAchievementBadRequest, *AdminUnlockAchievementUnauthorized, *AdminUnlockAchievementInternalServerError, error)

	AdminUpdateAchievement(params *AdminUpdateAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateAchievementOK, *AdminUpdateAchievementBadRequest, *AdminUpdateAchievementUnauthorized, *AdminUpdateAchievementNotFound, *AdminUpdateAchievementInternalServerError, error)

	AdminUpdateAchievementListOrder(params *AdminUpdateAchievementListOrderParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateAchievementListOrderNoContent, *AdminUpdateAchievementListOrderBadRequest, *AdminUpdateAchievementListOrderUnauthorized, *AdminUpdateAchievementListOrderNotFound, *AdminUpdateAchievementListOrderInternalServerError, error)

	ExportAchievements(params *ExportAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*ExportAchievementsOK, *ExportAchievementsUnauthorized, *ExportAchievementsForbidden, *ExportAchievementsInternalServerError, error)

	ImportAchievements(params *ImportAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*ImportAchievementsOK, *ImportAchievementsUnauthorized, *ImportAchievementsForbidden, *ImportAchievementsInternalServerError, error)

	PublicGetAchievement(params *PublicGetAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetAchievementOK, *PublicGetAchievementBadRequest, *PublicGetAchievementUnauthorized, *PublicGetAchievementNotFound, *PublicGetAchievementInternalServerError, error)

	PublicListAchievements(params *PublicListAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicListAchievementsOK, *PublicListAchievementsBadRequest, *PublicListAchievementsUnauthorized, *PublicListAchievementsNotFound, *PublicListAchievementsInternalServerError, error)

	PublicListUserAchievements(params *PublicListUserAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicListUserAchievementsOK, *PublicListUserAchievementsBadRequest, *PublicListUserAchievementsUnauthorized, *PublicListUserAchievementsNotFound, *PublicListUserAchievementsInternalServerError, error)

	PublicUnlockAchievement(params *PublicUnlockAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicUnlockAchievementNoContent, *PublicUnlockAchievementBadRequest, *PublicUnlockAchievementUnauthorized, *PublicUnlockAchievementInternalServerError, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AdminCreateNewAchievement creates new achievement

  <p>Required permission
			<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [CREATE]</code> and scope <code>social</code></p>
        	Other detail info:
          - achievementCode: Human readable unique code to indentify the achievement. Must be lowercase
			and maximum length is 32
          - incremental:  If the achievement is not incremental, it does not need to store a goal value
							of a stat to be unlocked.
                          If the achievement is incremental, it needs to set statCode and goalValue
          - statCode: Selected statistic code, from the published statistic code event.Human readable unique
			code to indentify the achievement. Must be lowercase and maximum length is 32
          - goalValue: Statistics value required to unlock the achievement.
          - defaultLanguage: localozation for achievement name and achievement description. Allowed format : en, en-US
          - slug: specify the image they want to use, it can be file image name or something
			to define the achievement icon.
*/
func (a *Client) AdminCreateNewAchievement(params *AdminCreateNewAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateNewAchievementCreated, *AdminCreateNewAchievementBadRequest, *AdminCreateNewAchievementUnauthorized, *AdminCreateNewAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminCreateNewAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminCreateNewAchievement",
		Method:             "POST",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminCreateNewAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminCreateNewAchievementCreated:
		return v, nil, nil, nil, nil
	case *AdminCreateNewAchievementBadRequest:
		return nil, v, nil, nil, nil
	case *AdminCreateNewAchievementUnauthorized:
		return nil, nil, v, nil, nil
	case *AdminCreateNewAchievementInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminDeleteAchievement deletes an achievement

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [DELETE]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminDeleteAchievement(params *AdminDeleteAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteAchievementNoContent, *AdminDeleteAchievementBadRequest, *AdminDeleteAchievementUnauthorized, *AdminDeleteAchievementNotFound, *AdminDeleteAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminDeleteAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminDeleteAchievement",
		Method:             "DELETE",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/{achievementCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminDeleteAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminDeleteAchievementNoContent:
		return v, nil, nil, nil, nil, nil
	case *AdminDeleteAchievementBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminDeleteAchievementUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminDeleteAchievementNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminDeleteAchievementInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminGetAchievement gets an achievement

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminGetAchievement(params *AdminGetAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminGetAchievementOK, *AdminGetAchievementBadRequest, *AdminGetAchievementUnauthorized, *AdminGetAchievementNotFound, *AdminGetAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminGetAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminGetAchievement",
		Method:             "GET",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/{achievementCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminGetAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminGetAchievementOK:
		return v, nil, nil, nil, nil, nil
	case *AdminGetAchievementBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminGetAchievementUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminGetAchievementNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminGetAchievementInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminListAchievements queries achievements

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminListAchievements(params *AdminListAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminListAchievementsOK, *AdminListAchievementsBadRequest, *AdminListAchievementsUnauthorized, *AdminListAchievementsNotFound, *AdminListAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminListAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminListAchievements",
		Method:             "GET",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminListAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminListAchievementsOK:
		return v, nil, nil, nil, nil, nil
	case *AdminListAchievementsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminListAchievementsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminListAchievementsNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminListAchievementsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminListUserAchievements queries user achievements include achieved and in progress

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:USER:{userId}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminListUserAchievements(params *AdminListUserAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*AdminListUserAchievementsOK, *AdminListUserAchievementsBadRequest, *AdminListUserAchievementsUnauthorized, *AdminListUserAchievementsNotFound, *AdminListUserAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminListUserAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminListUserAchievements",
		Method:             "GET",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/users/{userId}/achievements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminListUserAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminListUserAchievementsOK:
		return v, nil, nil, nil, nil, nil
	case *AdminListUserAchievementsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminListUserAchievementsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminListUserAchievementsNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminListUserAchievementsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUnlockAchievement unlocks an achievement

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:USER:{userId}:ACHIEVEMENT [UPDATE]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminUnlockAchievement(params *AdminUnlockAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUnlockAchievementNoContent, *AdminUnlockAchievementBadRequest, *AdminUnlockAchievementUnauthorized, *AdminUnlockAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUnlockAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUnlockAchievement",
		Method:             "PUT",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/users/{userId}/achievements/{achievementCode}/unlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminUnlockAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUnlockAchievementNoContent:
		return v, nil, nil, nil, nil
	case *AdminUnlockAchievementBadRequest:
		return nil, v, nil, nil, nil
	case *AdminUnlockAchievementUnauthorized:
		return nil, nil, v, nil, nil
	case *AdminUnlockAchievementInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateAchievement updates an achievement

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [UPDATE]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminUpdateAchievement(params *AdminUpdateAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateAchievementOK, *AdminUpdateAchievementBadRequest, *AdminUpdateAchievementUnauthorized, *AdminUpdateAchievementNotFound, *AdminUpdateAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateAchievement",
		Method:             "PUT",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/{achievementCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminUpdateAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateAchievementOK:
		return v, nil, nil, nil, nil, nil
	case *AdminUpdateAchievementBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminUpdateAchievementUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminUpdateAchievementNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminUpdateAchievementInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateAchievementListOrder updates achievements list order

  <p>Required permission
<code>ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [UPDATE]</code> and scope <code>social</code></p>
*/
func (a *Client) AdminUpdateAchievementListOrder(params *AdminUpdateAchievementListOrderParams, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateAchievementListOrderNoContent, *AdminUpdateAchievementListOrderBadRequest, *AdminUpdateAchievementListOrderUnauthorized, *AdminUpdateAchievementListOrderNotFound, *AdminUpdateAchievementListOrderInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateAchievementListOrderParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateAchievementListOrder",
		Method:             "PATCH",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/{achievementCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AdminUpdateAchievementListOrderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateAchievementListOrderNoContent:
		return v, nil, nil, nil, nil, nil
	case *AdminUpdateAchievementListOrderBadRequest:
		return nil, v, nil, nil, nil, nil
	case *AdminUpdateAchievementListOrderUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *AdminUpdateAchievementListOrderNotFound:
		return nil, nil, nil, v, nil, nil
	case *AdminUpdateAchievementListOrderInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ExportAchievements exports achievements configuration into a json file


				Required permission ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [READ]

				Required Scope: social

*/
func (a *Client) ExportAchievements(params *ExportAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*ExportAchievementsOK, *ExportAchievementsUnauthorized, *ExportAchievementsForbidden, *ExportAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExportAchievements",
		Method:             "GET",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExportAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ExportAchievementsOK:
		return v, nil, nil, nil, nil
	case *ExportAchievementsUnauthorized:
		return nil, v, nil, nil, nil
	case *ExportAchievementsForbidden:
		return nil, nil, v, nil, nil
	case *ExportAchievementsInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ImportAchievements imports achievements from file


				Required permission ADMIN:NAMESPACE:{namespace}:ACHIEVEMENT [UPDATE]

				Required Scope: social

				Import channels configuration from file. It will merge with existing channels.
				Available import strategy:
				- leaveOut: if channel with same key exist, the existing will be used and imported one will be ignored (default)
				- replace: if channel with same key exist, the imported channel will be used and existing one will be removed

*/
func (a *Client) ImportAchievements(params *ImportAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*ImportAchievementsOK, *ImportAchievementsUnauthorized, *ImportAchievementsForbidden, *ImportAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImportAchievements",
		Method:             "POST",
		PathPattern:        "/achievement/v1/admin/namespaces/{namespace}/achievements/import",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ImportAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ImportAchievementsOK:
		return v, nil, nil, nil, nil
	case *ImportAchievementsUnauthorized:
		return nil, v, nil, nil, nil
	case *ImportAchievementsForbidden:
		return nil, nil, v, nil, nil
	case *ImportAchievementsInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetAchievement gets an achievement

  <p>Required permission
<code>NAMESPACE:{namespace}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) PublicGetAchievement(params *PublicGetAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicGetAchievementOK, *PublicGetAchievementBadRequest, *PublicGetAchievementUnauthorized, *PublicGetAchievementNotFound, *PublicGetAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PublicGetAchievement",
		Method:             "GET",
		PathPattern:        "/achievement/v1/public/namespaces/{namespace}/achievements/{achievementCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetAchievementOK:
		return v, nil, nil, nil, nil, nil
	case *PublicGetAchievementBadRequest:
		return nil, v, nil, nil, nil, nil
	case *PublicGetAchievementUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *PublicGetAchievementNotFound:
		return nil, nil, nil, v, nil, nil
	case *PublicGetAchievementInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicListAchievements queries achievements

  <p>Required permission
<code>NAMESPACE:{namespace}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) PublicListAchievements(params *PublicListAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicListAchievementsOK, *PublicListAchievementsBadRequest, *PublicListAchievementsUnauthorized, *PublicListAchievementsNotFound, *PublicListAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicListAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PublicListAchievements",
		Method:             "GET",
		PathPattern:        "/achievement/v1/public/namespaces/{namespace}/achievements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicListAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicListAchievementsOK:
		return v, nil, nil, nil, nil, nil
	case *PublicListAchievementsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *PublicListAchievementsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *PublicListAchievementsNotFound:
		return nil, nil, nil, v, nil, nil
	case *PublicListAchievementsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicListUserAchievements queries user achievements include achieved and in progress

  <p>Required permission
<code>NAMESPACE:{namespace}:USER:{userId}:ACHIEVEMENT [READ]</code> and scope <code>social</code></p>
*/
func (a *Client) PublicListUserAchievements(params *PublicListUserAchievementsParams, authInfo runtime.ClientAuthInfoWriter) (*PublicListUserAchievementsOK, *PublicListUserAchievementsBadRequest, *PublicListUserAchievementsUnauthorized, *PublicListUserAchievementsNotFound, *PublicListUserAchievementsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicListUserAchievementsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PublicListUserAchievements",
		Method:             "GET",
		PathPattern:        "/achievement/v1/public/namespaces/{namespace}/users/{userId}/achievements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicListUserAchievementsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicListUserAchievementsOK:
		return v, nil, nil, nil, nil, nil
	case *PublicListUserAchievementsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *PublicListUserAchievementsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *PublicListUserAchievementsNotFound:
		return nil, nil, nil, v, nil, nil
	case *PublicListUserAchievementsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicUnlockAchievement unlocks an achievement

  <p>Required permission
<code>NAMESPACE:{namespace}:USER:{userId}:ACHIEVEMENT [UPDATE]</code> and scope <code>social</code></p>
*/
func (a *Client) PublicUnlockAchievement(params *PublicUnlockAchievementParams, authInfo runtime.ClientAuthInfoWriter) (*PublicUnlockAchievementNoContent, *PublicUnlockAchievementBadRequest, *PublicUnlockAchievementUnauthorized, *PublicUnlockAchievementInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicUnlockAchievementParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PublicUnlockAchievement",
		Method:             "PUT",
		PathPattern:        "/achievement/v1/public/namespaces/{namespace}/users/{userId}/achievements/{achievementCode}/unlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicUnlockAchievementReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicUnlockAchievementNoContent:
		return v, nil, nil, nil, nil
	case *PublicUnlockAchievementBadRequest:
		return nil, v, nil, nil, nil
	case *PublicUnlockAchievementUnauthorized:
		return nil, nil, v, nil, nil
	case *PublicUnlockAchievementInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
