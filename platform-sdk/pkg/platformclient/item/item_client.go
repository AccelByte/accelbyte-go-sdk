// Code generated by go-swagger; DO NOT EDIT.

package item

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new item API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for item API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AcquireItem(params *AcquireItemParams, authInfo runtime.ClientAuthInfoWriter) (*AcquireItemOK, *AcquireItemNotFound, error)

	BulkGetLocaleItems(params *BulkGetLocaleItemsParams, authInfo runtime.ClientAuthInfoWriter) (*BulkGetLocaleItemsOK, *BulkGetLocaleItemsNotFound, error)

	CreateItem(params *CreateItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateItemCreated, *CreateItemBadRequest, *CreateItemNotFound, *CreateItemConflict, *CreateItemUnprocessableEntity, error)

	DefeatureItem(params *DefeatureItemParams, authInfo runtime.ClientAuthInfoWriter) (*DefeatureItemOK, *DefeatureItemNotFound, *DefeatureItemConflict, error)

	DeleteItem(params *DeleteItemParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteItemNoContent, *DeleteItemNotFound, error)

	DisableItem(params *DisableItemParams, authInfo runtime.ClientAuthInfoWriter) (*DisableItemOK, *DisableItemNotFound, *DisableItemConflict, error)

	EnableItem(params *EnableItemParams, authInfo runtime.ClientAuthInfoWriter) (*EnableItemOK, *EnableItemNotFound, *EnableItemConflict, error)

	FeatureItem(params *FeatureItemParams, authInfo runtime.ClientAuthInfoWriter) (*FeatureItemOK, *FeatureItemNotFound, *FeatureItemConflict, error)

	GetApp(params *GetAppParams, authInfo runtime.ClientAuthInfoWriter) (*GetAppOK, error)

	GetItem(params *GetItemParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemOK, *GetItemNotFound, error)

	GetItemByAppID(params *GetItemByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemByAppIDOK, *GetItemByAppIDNotFound, error)

	GetItemBySku(params *GetItemBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemBySkuOK, *GetItemBySkuNotFound, error)

	GetItemDynamicData(params *GetItemDynamicDataParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemDynamicDataOK, *GetItemDynamicDataNotFound, error)

	GetItemIDBySku(params *GetItemIDBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemIDBySkuOK, *GetItemIDBySkuNotFound, error)

	GetLocaleItem(params *GetLocaleItemParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocaleItemOK, *GetLocaleItemNotFound, error)

	GetLocaleItemBySku(params *GetLocaleItemBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocaleItemBySkuOK, *GetLocaleItemBySkuNotFound, error)

	ListBasicItemsByFeatures(params *ListBasicItemsByFeaturesParams, authInfo runtime.ClientAuthInfoWriter) (*ListBasicItemsByFeaturesOK, error)

	PublicBulkGetItems(params *PublicBulkGetItemsParams) (*PublicBulkGetItemsOK, *PublicBulkGetItemsNotFound, error)

	PublicGetApp(params *PublicGetAppParams) (*PublicGetAppOK, *PublicGetAppNotFound, error)

	PublicGetItem(params *PublicGetItemParams) (*PublicGetItemOK, *PublicGetItemNotFound, error)

	PublicGetItemByAppID(params *PublicGetItemByAppIDParams) (*PublicGetItemByAppIDOK, *PublicGetItemByAppIDNotFound, error)

	PublicGetItemBySku(params *PublicGetItemBySkuParams) (*PublicGetItemBySkuOK, *PublicGetItemBySkuNotFound, error)

	PublicGetItemDynamicData(params *PublicGetItemDynamicDataParams) (*PublicGetItemDynamicDataOK, *PublicGetItemDynamicDataNotFound, error)

	PublicQueryItems(params *PublicQueryItemsParams) (*PublicQueryItemsOK, *PublicQueryItemsNotFound, *PublicQueryItemsUnprocessableEntity, error)

	PublicSearchItems(params *PublicSearchItemsParams) (*PublicSearchItemsOK, *PublicSearchItemsNotFound, error)

	QueryItems(params *QueryItemsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryItemsOK, *QueryItemsNotFound, *QueryItemsUnprocessableEntity, error)

	QueryUncategorizedItems(params *QueryUncategorizedItemsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUncategorizedItemsOK, *QueryUncategorizedItemsNotFound, *QueryUncategorizedItemsUnprocessableEntity, error)

	ReturnItem(params *ReturnItemParams, authInfo runtime.ClientAuthInfoWriter) (*ReturnItemNoContent, *ReturnItemNotFound, *ReturnItemUnprocessableEntity, error)

	SearchItems(params *SearchItemsParams, authInfo runtime.ClientAuthInfoWriter) (*SearchItemsOK, *SearchItemsNotFound, error)

	SyncInGameItem(params *SyncInGameItemParams, authInfo runtime.ClientAuthInfoWriter) (*SyncInGameItemOK, *SyncInGameItemBadRequest, *SyncInGameItemNotFound, *SyncInGameItemConflict, *SyncInGameItemUnprocessableEntity, error)

	UpdateApp(params *UpdateAppParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAppOK, *UpdateAppNotFound, *UpdateAppConflict, *UpdateAppUnprocessableEntity, error)

	UpdateItem(params *UpdateItemParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateItemOK, *UpdateItemBadRequest, *UpdateItemNotFound, *UpdateItemConflict, *UpdateItemUnprocessableEntity, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AcquireItem acquires item

  <b>[SERVICE COMMUNICATION ONLY]</b> This api is used for acquiring a published item while the item is maxCount limited, it will decrease the sale available count.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: acquire result</li></ul>
*/
func (a *Client) AcquireItem(params *AcquireItemParams, authInfo runtime.ClientAuthInfoWriter) (*AcquireItemOK, *AcquireItemNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAcquireItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "acquireItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/acquire",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AcquireItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *AcquireItemOK:
		return v, nil, nil
	case *AcquireItemNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  BulkGetLocaleItems bulks get locale items

  This API is used to bulk get locale items. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: the list of items info</li></ul>
*/
func (a *Client) BulkGetLocaleItems(params *BulkGetLocaleItemsParams, authInfo runtime.ClientAuthInfoWriter) (*BulkGetLocaleItemsOK, *BulkGetLocaleItemsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkGetLocaleItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "bulkGetLocaleItems",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/locale/byIds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &BulkGetLocaleItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *BulkGetLocaleItemsOK:
		return v, nil, nil
	case *BulkGetLocaleItemsNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateItem creates an item

  This API is used to create an item. APP item only can created in publisher namespace.<p>An item create example:<p><pre><code>{
   "categoryPath": "/games",
   "localizations": \{
       "en": \{
           "title":"required",
           "description":"optional",
           "longDescription":"optional",
           "localExt": \{
                  "properties":\[
                                   \{
                                       "key1":"value1",
                                       "key2":"value2"
                                   \}
                  \],
                  "functions":\[
                                   \{
                                       "key1":"value1",
                                       "key2":"value2"
                                   \}
                 \]
           \}
        \}
   \},
   "images": \[
     \{
           "as":"optional, image for",
           "caption":"optional",
           "height":10,
           "width":10,
           "imageUrl":"http://img-url-required",
           "smallImageUrl":"http://small-img-url-required"
     \}
   \],
   "thumbnailUrl": "optional, thumbnail url",
   "status": "ACTIVE",
   "listable": true,
   "purchasable": true,
   "itemType": "APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])",
   "name": "required, also will be used as entitlement name",
   "entitlementType": "DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)",
   "useCount": 1(optional, required if the entitlement type is consumable),
   "stackable": false,
   "appId": "optional, required if itemType is APP",
   "appType": "GAME(optional, required if itemType is APP)",
   "seasonType": "PASS(optional, required if itemType is SEASON)",
   "baseAppId": "optional, set value of game app id if you want to link to a game",
   "targetCurrencyCode": "optional, required if itemType is COINS",
   "targetNamespace": "optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item
   created belongs to the publisher namespace",
   "sku": "optional, commonly unique item code",
   "regionData": \{
       "US(store's default region is required)": \[
         \{
            "price":10,
            "discountPercentage": 0(integer, optional, range[0,100], discountedPrice = price  \* ((100 - discountPercentage) \* 0.01),
              will use it to calculate discounted price if it is not 0),
            "discountAmount":0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0),
            "currencyCode":"code(required, example: USD)",
            "currencyNamespace":"test-ns-required",
            "trialPrice":5(required while fixedTrialCycles set, should >=0 and <= price, will same as price if not present),
            "purchaseAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "expireAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "discountPurchaseAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "discountExpireAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
         \}
       \]
   \},
   "itemIds": \[
       "itemId"
   \],
   "recurring": \{
       "cycle":"MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])",
       "fixedFreeDays":0(integer, fixed free days, 0 means not set),
       "fixedTrialCycles":0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set),
       "graceDays":7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7)
   \},
   "tags": \[
       "tag"
   \],
   "features": \[
       "feature"
   \],
   "clazz": "weapon",
   "boothName": "C_campaign1",
   "displayOrder": 1000,
   "ext": \{
       "properties":\[
           \{
               "key1":"value1",
               "key2":"value2"
           \}
       \],
       "functions":\[
           \{
               "key1":"value1",
               "key2":"value2"
           \}
       \]
   \},
   "maxCountPerUser": 1(integer, optional, -1 means UNLIMITED),
   "maxCount": 1(integer, optional, -1 means UNLIMITED, unset when itemType is CODE)
}</code></pre>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=1 (CREATE)</li><li><i>Returns</i>: created item data</li></ul>
*/
func (a *Client) CreateItem(params *CreateItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateItemCreated, *CreateItemBadRequest, *CreateItemNotFound, *CreateItemConflict, *CreateItemUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createItem",
		Method:             "POST",
		PathPattern:        "/admin/namespaces/{namespace}/items",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateItemCreated:
		return v, nil, nil, nil, nil, nil
	case *CreateItemBadRequest:
		return nil, v, nil, nil, nil, nil
	case *CreateItemNotFound:
		return nil, nil, v, nil, nil, nil
	case *CreateItemConflict:
		return nil, nil, nil, v, nil, nil
	case *CreateItemUnprocessableEntity:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DefeatureItem defeatures an item

  Remove a feature from an item.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated item</li></ul>
*/
func (a *Client) DefeatureItem(params *DefeatureItemParams, authInfo runtime.ClientAuthInfoWriter) (*DefeatureItemOK, *DefeatureItemNotFound, *DefeatureItemConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDefeatureItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "defeatureItem",
		Method:             "DELETE",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/features/{feature}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DefeatureItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DefeatureItemOK:
		return v, nil, nil, nil
	case *DefeatureItemNotFound:
		return nil, v, nil, nil
	case *DefeatureItemConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteItem deletes an item

  This API is used to delete an item permanently, usually for test purpose.<b>DO NOT delete already published item.</b><p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=8 (DELETE)</li></ul>
*/
func (a *Client) DeleteItem(params *DeleteItemParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteItemNoContent, *DeleteItemNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteItem",
		Method:             "DELETE",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteItemNoContent:
		return v, nil, nil
	case *DeleteItemNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DisableItem disables an item

  Disable an item.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated item</li></ul>
*/
func (a *Client) DisableItem(params *DisableItemParams, authInfo runtime.ClientAuthInfoWriter) (*DisableItemOK, *DisableItemNotFound, *DisableItemConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisableItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "disableItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/disable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DisableItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DisableItemOK:
		return v, nil, nil, nil
	case *DisableItemNotFound:
		return nil, v, nil, nil
	case *DisableItemConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  EnableItem enables an item

  Enable an item.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated item</li></ul>
*/
func (a *Client) EnableItem(params *EnableItemParams, authInfo runtime.ClientAuthInfoWriter) (*EnableItemOK, *EnableItemNotFound, *EnableItemConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/enable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *EnableItemOK:
		return v, nil, nil, nil
	case *EnableItemNotFound:
		return nil, v, nil, nil
	case *EnableItemConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  FeatureItem features an item

  Add a feature to an item.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated item</li></ul>
*/
func (a *Client) FeatureItem(params *FeatureItemParams, authInfo runtime.ClientAuthInfoWriter) (*FeatureItemOK, *FeatureItemNotFound, *FeatureItemConflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFeatureItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "featureItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/features/{feature}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FeatureItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *FeatureItemOK:
		return v, nil, nil, nil
	case *FeatureItemNotFound:
		return nil, v, nil, nil
	case *FeatureItemConflict:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetApp gets an app info

  This API is used to get an app info.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: app data</li></ul>
*/
func (a *Client) GetApp(params *GetAppParams, authInfo runtime.ClientAuthInfoWriter) (*GetAppOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAppParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getApp",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/app",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAppReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *GetAppOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetItem gets an item

  This API is used to get an item.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: item data</li></ul>
*/
func (a *Client) GetItem(params *GetItemParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemOK, *GetItemNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getItem",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetItemOK:
		return v, nil, nil
	case *GetItemNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetItemByAppID gets item by app Id

  This API is used to get the item by appId.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)<li><i>Returns</i>: the item with that appId</li></ul>
*/
func (a *Client) GetItemByAppID(params *GetItemByAppIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemByAppIDOK, *GetItemByAppIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetItemByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getItemByAppId",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetItemByAppIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetItemByAppIDOK:
		return v, nil, nil
	case *GetItemByAppIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetItemBySku gets item by sku

  This API is used to get the item by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)<li><i>Returns</i>: the item with sku</li></ul>
*/
func (a *Client) GetItemBySku(params *GetItemBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemBySkuOK, *GetItemBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetItemBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getItemBySku",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetItemBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetItemBySkuOK:
		return v, nil, nil
	case *GetItemBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetItemDynamicData gets item dynamic data

  Get item dynamic data for published item.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: item dynamic data</li></ul>
*/
func (a *Client) GetItemDynamicData(params *GetItemDynamicDataParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemDynamicDataOK, *GetItemDynamicDataNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetItemDynamicDataParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getItemDynamicData",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/dynamic",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetItemDynamicDataReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetItemDynamicDataOK:
		return v, nil, nil
	case *GetItemDynamicDataNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetItemIDBySku gets item Id by sku

  <b>[SERVICE COMMUNICATION ONLY]</b> This API is used to get the itemId by sku.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)<li><i>Returns</i>: the itemId with sku</li></ul>
*/
func (a *Client) GetItemIDBySku(params *GetItemIDBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetItemIDBySkuOK, *GetItemIDBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetItemIDBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getItemIdBySku",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/itemId/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetItemIDBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetItemIDBySkuOK:
		return v, nil, nil
	case *GetItemIDBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetLocaleItem gets an item in locale

  This API is used to get an item in specific locale. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: item data</li></ul>
*/
func (a *Client) GetLocaleItem(params *GetLocaleItemParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocaleItemOK, *GetLocaleItemNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLocaleItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLocaleItem",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/locale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLocaleItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetLocaleItemOK:
		return v, nil, nil
	case *GetLocaleItemNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetLocaleItemBySku gets an item by sku in locale

  This API is used to get an item by sku in specific locale. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: item data</li></ul>
*/
func (a *Client) GetLocaleItemBySku(params *GetLocaleItemBySkuParams, authInfo runtime.ClientAuthInfoWriter) (*GetLocaleItemBySkuOK, *GetLocaleItemBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLocaleItemBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLocaleItemBySku",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/bySku/locale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLocaleItemBySkuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *GetLocaleItemBySkuOK:
		return v, nil, nil
	case *GetLocaleItemBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ListBasicItemsByFeatures lists basic items by features

  <b>[SERVICE COMMUNICATION ONLY]</b> This API is used to list basic items by features.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: the list of basic items</li></ul>
*/
func (a *Client) ListBasicItemsByFeatures(params *ListBasicItemsByFeaturesParams, authInfo runtime.ClientAuthInfoWriter) (*ListBasicItemsByFeaturesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListBasicItemsByFeaturesParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listBasicItemsByFeatures",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/byFeatures/basic",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListBasicItemsByFeaturesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *ListBasicItemsByFeaturesOK:
		return v, nil
	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicBulkGetItems bulks get locale items

  This API is used to bulk get locale items. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store items)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store items)</li><li><i>Returns</i>: the list of items info</li></ul>
*/
func (a *Client) PublicBulkGetItems(params *PublicBulkGetItemsParams) (*PublicBulkGetItemsOK, *PublicBulkGetItemsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicBulkGetItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicBulkGetItems",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/locale/byIds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicBulkGetItemsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicBulkGetItemsOK:
		return v, nil, nil
	case *PublicBulkGetItemsNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetApp gets an app in locale

  This API is used to get an app in locale. If app not exist in specific region, default region app will return.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store app)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store app)</li><li><i>Returns</i>: app data</li></ul>
*/
func (a *Client) PublicGetApp(params *PublicGetAppParams) (*PublicGetAppOK, *PublicGetAppNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetAppParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetApp",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/{itemId}/app/locale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetAppReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetAppOK:
		return v, nil, nil
	case *PublicGetAppNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetItem gets an item in locale

  This API is used to get an item in locale. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Returns</i>: item data</li></ul>
*/
func (a *Client) PublicGetItem(params *PublicGetItemParams) (*PublicGetItemOK, *PublicGetItemNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetItem",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/{itemId}/locale",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetItemReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetItemOK:
		return v, nil, nil
	case *PublicGetItemNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetItemByAppID gets item by app Id

  This API is used to get item by appId.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Returns</i>: the item with that appId</li></ul>
*/
func (a *Client) PublicGetItemByAppID(params *PublicGetItemByAppIDParams) (*PublicGetItemByAppIDOK, *PublicGetItemByAppIDNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetItemByAppIDParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetItemByAppId",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/byAppId",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetItemByAppIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetItemByAppIDOK:
		return v, nil, nil
	case *PublicGetItemByAppIDNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetItemBySku gets item by sku

  This API is used to get the item by sku.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Returns</i>: the item with sku</li></ul>
*/
func (a *Client) PublicGetItemBySku(params *PublicGetItemBySkuParams) (*PublicGetItemBySkuOK, *PublicGetItemBySkuNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetItemBySkuParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetItemBySku",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/bySku",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetItemBySkuReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetItemBySkuOK:
		return v, nil, nil
	case *PublicGetItemBySkuNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicGetItemDynamicData gets item dynamic data

  Get item dynamic data for a published item.<br>Other detail info: <ul><li><i>Returns</i>: item dynamic data</li></ul>
*/
func (a *Client) PublicGetItemDynamicData(params *PublicGetItemDynamicDataParams) (*PublicGetItemDynamicDataOK, *PublicGetItemDynamicDataNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicGetItemDynamicDataParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicGetItemDynamicData",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/{itemId}/dynamic",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicGetItemDynamicDataReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicGetItemDynamicDataOK:
		return v, nil, nil
	case *PublicGetItemDynamicDataNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicQueryItems queries items by criteria

  This API is used to query items by criteria within a store. If item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Returns</i>: the list of items</li></ul>
*/
func (a *Client) PublicQueryItems(params *PublicQueryItemsParams) (*PublicQueryItemsOK, *PublicQueryItemsNotFound, *PublicQueryItemsUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicQueryItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicQueryItems",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/byCriteria",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicQueryItemsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *PublicQueryItemsOK:
		return v, nil, nil, nil
	case *PublicQueryItemsNotFound:
		return nil, v, nil, nil
	case *PublicQueryItemsUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  PublicSearchItems searches items by keyword

  This API is used to search items by keyword in title, description and long description, It's language constrained, also if item not exist in specific region, default region item will return.<p>Other detail info: <ul><li><i>Optional permission</i>: resource="PREVIEW", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Optional permission</i>: resource="SANDBOX", action=1(CREATE) (user with this permission can view draft store item)</li><li><i>Returns</i>: the list of items</li></ul>
*/
func (a *Client) PublicSearchItems(params *PublicSearchItemsParams) (*PublicSearchItemsOK, *PublicSearchItemsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicSearchItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "publicSearchItems",
		Method:             "GET",
		PathPattern:        "/public/namespaces/{namespace}/items/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PublicSearchItemsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *PublicSearchItemsOK:
		return v, nil, nil
	case *PublicSearchItemsNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryItems queries items by criteria

  This API is used to query items by criteria within a store.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: the list of items</li></ul>
*/
func (a *Client) QueryItems(params *QueryItemsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryItemsOK, *QueryItemsNotFound, *QueryItemsUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryItems",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/byCriteria",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *QueryItemsOK:
		return v, nil, nil, nil
	case *QueryItemsNotFound:
		return nil, v, nil, nil
	case *QueryItemsUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueryUncategorizedItems queries uncategorized items

  This API is used to query uncategorized items within a store.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)</li><li><i>Returns</i>: the list of uncategorized items</li></ul>
*/
func (a *Client) QueryUncategorizedItems(params *QueryUncategorizedItemsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryUncategorizedItemsOK, *QueryUncategorizedItemsNotFound, *QueryUncategorizedItemsUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryUncategorizedItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "queryUncategorizedItems",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/uncategorized",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryUncategorizedItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *QueryUncategorizedItemsOK:
		return v, nil, nil, nil
	case *QueryUncategorizedItemsNotFound:
		return nil, v, nil, nil
	case *QueryUncategorizedItemsUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ReturnItem returns item

  <b>[SERVICE COMMUNICATION ONLY]</b> This api is used for returning a published item while the item is maxCount limited, it will increase the sale available count if orderNo already acquired.<br>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li></ul>
*/
func (a *Client) ReturnItem(params *ReturnItemParams, authInfo runtime.ClientAuthInfoWriter) (*ReturnItemNoContent, *ReturnItemNotFound, *ReturnItemUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReturnItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "returnItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/return",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReturnItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ReturnItemNoContent:
		return v, nil, nil, nil
	case *ReturnItemNotFound:
		return nil, v, nil, nil
	case *ReturnItemUnprocessableEntity:
		return nil, nil, v, nil
	default:
		return nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SearchItems searches items by keyword

  This API is used to search items by keyword in title, description and long description within a store.<p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=2 (READ)<li><i>Returns</i>: the list of items</li></ul>
*/
func (a *Client) SearchItems(params *SearchItemsParams, authInfo runtime.ClientAuthInfoWriter) (*SearchItemsOK, *SearchItemsNotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSearchItemsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "searchItems",
		Method:             "GET",
		PathPattern:        "/admin/namespaces/{namespace}/items/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SearchItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}

	switch v := result.(type) {

	case *SearchItemsOK:
		return v, nil, nil
	case *SearchItemsNotFound:
		return nil, v, nil
	default:
		return nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SyncInGameItem syncs an in game item

  This API is used to sync an in game item in game namespace to publisher namespace, at current BUNDLE can't be synced.<p>The synced item has an additional field targetItemId besides targetNamespace, mostly this item should not modified manually again. <p>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: item data</li></ul>
*/
func (a *Client) SyncInGameItem(params *SyncInGameItemParams, authInfo runtime.ClientAuthInfoWriter) (*SyncInGameItemOK, *SyncInGameItemBadRequest, *SyncInGameItemNotFound, *SyncInGameItemConflict, *SyncInGameItemUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncInGameItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "syncInGameItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SyncInGameItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SyncInGameItemOK:
		return v, nil, nil, nil, nil, nil
	case *SyncInGameItemBadRequest:
		return nil, v, nil, nil, nil, nil
	case *SyncInGameItemNotFound:
		return nil, nil, v, nil, nil, nil
	case *SyncInGameItemConflict:
		return nil, nil, nil, v, nil, nil
	case *SyncInGameItemUnprocessableEntity:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateApp updates an app

  This API is used to update an app.<p>An app update example:<p><pre><code>{
  "developer": "accelbyte",
  "publisher": "accelbyte",
  "websiteUrl": "http://accelbyte.io",
  "forumUrl": "http://accelbyte.io",
  "platforms": \["Windows(allowed values: Windows, MacOS, Linux, IOS, Android)"\],
  "platformRequirements": \{
    "Windows": \[
      \{
        "label":"minimum(can be minimum or recommended)",
        "osVersion":"os version",
        "processor":"processor",
        "ram":"RAM",
        "graphics":"graphics",
        "directXVersion":"directXVersion",
        "diskSpace":"diskSpace",
        "soundCard":"soundCard",
        "additionals":"additionals"
      \}
     \]
  \},
  "carousel": \[
    \{
      "type":"image(allowed values: image, video)",
      "videoSource":"generic(allowed values:generic, youtube, viemo)",
      "url":"url",
      "alt":"alternative url or text",
      "thumbnailUrl":"thumbnail url",
      "previewUrl":"preview url",
    \}
  \],
  "localizations": \{
    "en": \{
      "slogan":"slogan",
      "announcement":"announcement",
    \}
  \},
  "primaryGenre": "Action",
  "genres": \["Action", "Adventure"\],
  "players": \["Single"\],
  "releaseDate": "optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
}</code></pre>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated app data</li></ul>
*/
func (a *Client) UpdateApp(params *UpdateAppParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateAppOK, *UpdateAppNotFound, *UpdateAppConflict, *UpdateAppUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAppParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateApp",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}/app",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateAppReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateAppOK:
		return v, nil, nil, nil, nil
	case *UpdateAppNotFound:
		return nil, v, nil, nil, nil
	case *UpdateAppConflict:
		return nil, nil, v, nil, nil
	case *UpdateAppUnprocessableEntity:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateItem updates an item

  This API is used to update an item.<p>An item update example:<p><pre><code>{
	"categoryPath": "/games",
	"localizations": \{
       "en": \{
           "title":"required",
           "description":"optional",
           "longDescription":"optional",
           "localExt": \{
                  "properties":\[
                                   \{
                                       "key1":"value1",
                                       "key2":"value2"
                                   \}
                  \],
                  "functions":\[
                                   \{
                                       "key1":"value1",
                                       "key2":"value2"
                                   \}
                 \]
           \}
       \}
   \},
   "images": \[
     \{
           "as":"optional, image for",
           "caption":"optional",
           "height":10,
           "width":10,
           "imageUrl":"http://img-url-required",
           "smallImageUrl":"http://small-img-url-required"
     \}
   \],
   "thumbnailUrl": "optional, thumbnail url",
   "status": "ACTIVE",
   "listable": true,
   "purchasable": true,
   "itemType": "APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])",
   "name": "optional",
   "entitlementType": "DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)",
   "useCount": 1(optional, required if the entitlement type is consumable),
   "stackable": false,
   "appId": "optional, required if itemType is APP",
   "baseAppId": "optional, set value of game app id if you want to link to a game",
   "appType": "GAME(optional, required if itemType is APP)",
   "seasonType": "PASS(optional, required if itemType is SEASON)",
   "sku": "optional, commonly unique item code",
   "targetCurrencyCode": "optional, required if itemType is COINS",
   "targetNamespace": "optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item
   created belongs to the publisher namespace",
   "regionData": \{
       "US(store's default region is required)": \[
         \{
            "price":10,
            "discountPercentage":0(integer, optional, range[0,100], discountedPrice = price\*((100 - discountPercentage) \* 0.01),
              if it is not 0, will use it to calculate discounted price),
            "discountAmount":0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0),
            "currencyCode":"code(required, example: USD)",
            "currencyNamespace":"test-ns-required",
            "trialPrice":5(required while fixedTrialCycles set, should >=0 and <= price, will same as price if not present),
            "purchaseAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "expireAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "discountPurchaseAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "discountExpireAt":"optional yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
         \}
       \]
   \},
   "itemIds": \[
       "itemId"
   \],
   "recurring": \{
       "cycle":"MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])",
       "fixedFreeDays":0(integer, fixed free days, 0 means not set),
       "fixedTrialCycles":0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set),
       "graceDays":7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7)
   \},
   "tags": \[
       "tag"
   \],
   "features": \[
       "feature"
   \],
   "clazz": "weapon",
   "boothName": "C_campaign1",
   "displayOrder": 1000,
   "ext": \{
       "properties":\[
           \{
               "key1":"value1",
               "key2":"value2"
           \}
       \],
       "functions":\[
           \{
               "key1":"value1",
               "key2":"value2"
           \}
       \]
   \},
   "maxCountPerUser": 1(integer, optional, -1 means UNLIMITED),
   "maxCount": 1(integer, optional, -1 means UNLIMITED, new value should >= old value if both old value and new value is
   limited, unset when item type is CODE)
}</code></pre>Other detail info: <ul><li><i>Required permission</i>: resource="ADMIN:NAMESPACE:{namespace}:ITEM", action=4 (UPDATE)</li><li><i>Returns</i>: updated item data</li></ul>
*/
func (a *Client) UpdateItem(params *UpdateItemParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateItemOK, *UpdateItemBadRequest, *UpdateItemNotFound, *UpdateItemConflict, *UpdateItemUnprocessableEntity, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateItemParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateItem",
		Method:             "PUT",
		PathPattern:        "/admin/namespaces/{namespace}/items/{itemId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateItemOK:
		return v, nil, nil, nil, nil, nil
	case *UpdateItemBadRequest:
		return nil, v, nil, nil, nil, nil
	case *UpdateItemNotFound:
		return nil, nil, v, nil, nil, nil
	case *UpdateItemConflict:
		return nil, nil, nil, v, nil, nil
	case *UpdateItemUnprocessableEntity:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
