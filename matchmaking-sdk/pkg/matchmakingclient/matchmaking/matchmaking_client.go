// Code generated by go-swagger; DO NOT EDIT.

package matchmaking

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new matchmaking API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for matchmaking API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AddUserIntoSessionInChannel(params *AddUserIntoSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*AddUserIntoSessionInChannelOK, *AddUserIntoSessionInChannelBadRequest, *AddUserIntoSessionInChannelUnauthorized, *AddUserIntoSessionInChannelForbidden, *AddUserIntoSessionInChannelNotFound, *AddUserIntoSessionInChannelInternalServerError, error)

	BulkGetSessions(params *BulkGetSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*BulkGetSessionsOK, *BulkGetSessionsBadRequest, *BulkGetSessionsUnauthorized, *BulkGetSessionsForbidden, *BulkGetSessionsNotFound, *BulkGetSessionsInternalServerError, error)

	CreateChannelHandler(params *CreateChannelHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateChannelHandlerCreated, *CreateChannelHandlerBadRequest, *CreateChannelHandlerUnauthorized, *CreateChannelHandlerForbidden, *CreateChannelHandlerConflict, *CreateChannelHandlerInternalServerError, error)

	DeleteChannelHandler(params *DeleteChannelHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteChannelHandlerNoContent, *DeleteChannelHandlerUnauthorized, *DeleteChannelHandlerForbidden, *DeleteChannelHandlerInternalServerError, error)

	DeleteSessionInChannel(params *DeleteSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSessionInChannelNoContent, *DeleteSessionInChannelBadRequest, *DeleteSessionInChannelUnauthorized, *DeleteSessionInChannelForbidden, *DeleteSessionInChannelNotFound, *DeleteSessionInChannelInternalServerError, error)

	DeleteUserFromSessionInChannel(params *DeleteUserFromSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserFromSessionInChannelOK, *DeleteUserFromSessionInChannelNoContent, *DeleteUserFromSessionInChannelBadRequest, *DeleteUserFromSessionInChannelUnauthorized, *DeleteUserFromSessionInChannelForbidden, *DeleteUserFromSessionInChannelNotFound, *DeleteUserFromSessionInChannelInternalServerError, error)

	DequeueSessionHandler(params *DequeueSessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*DequeueSessionHandlerNoContent, *DequeueSessionHandlerBadRequest, *DequeueSessionHandlerUnauthorized, *DequeueSessionHandlerForbidden, *DequeueSessionHandlerNotFound, *DequeueSessionHandlerInternalServerError, error)

	ExportChannels(params *ExportChannelsParams, authInfo runtime.ClientAuthInfoWriter) (*ExportChannelsOK, *ExportChannelsUnauthorized, *ExportChannelsForbidden, *ExportChannelsInternalServerError, error)

	GetAllChannelsHandler(params *GetAllChannelsHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllChannelsHandlerOK, *GetAllChannelsHandlerBadRequest, *GetAllChannelsHandlerUnauthorized, *GetAllChannelsHandlerForbidden, *GetAllChannelsHandlerConflict, *GetAllChannelsHandlerInternalServerError, error)

	GetAllPartyInAllChannel(params *GetAllPartyInAllChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllPartyInAllChannelOK, *GetAllPartyInAllChannelBadRequest, *GetAllPartyInAllChannelUnauthorized, *GetAllPartyInAllChannelForbidden, *GetAllPartyInAllChannelNotFound, *GetAllPartyInAllChannelInternalServerError, error)

	GetAllPartyInChannel(params *GetAllPartyInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllPartyInChannelOK, *GetAllPartyInChannelBadRequest, *GetAllPartyInChannelUnauthorized, *GetAllPartyInChannelForbidden, *GetAllPartyInChannelNotFound, *GetAllPartyInChannelInternalServerError, error)

	GetAllSessionsInChannel(params *GetAllSessionsInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllSessionsInChannelOK, *GetAllSessionsInChannelBadRequest, *GetAllSessionsInChannelUnauthorized, *GetAllSessionsInChannelForbidden, *GetAllSessionsInChannelNotFound, *GetAllSessionsInChannelInternalServerError, error)

	GetSessionHistoryDetailed(params *GetSessionHistoryDetailedParams, authInfo runtime.ClientAuthInfoWriter) (*GetSessionHistoryDetailedOK, *GetSessionHistoryDetailedBadRequest, *GetSessionHistoryDetailedUnauthorized, *GetSessionHistoryDetailedForbidden, *GetSessionHistoryDetailedNotFound, *GetSessionHistoryDetailedInternalServerError, error)

	GetSingleMatchmakingChannel(params *GetSingleMatchmakingChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetSingleMatchmakingChannelOK, *GetSingleMatchmakingChannelBadRequest, *GetSingleMatchmakingChannelUnauthorized, *GetSingleMatchmakingChannelForbidden, *GetSingleMatchmakingChannelNotFound, *GetSingleMatchmakingChannelInternalServerError, error)

	ImportChannels(params *ImportChannelsParams, authInfo runtime.ClientAuthInfoWriter) (*ImportChannelsOK, *ImportChannelsBadRequest, *ImportChannelsUnauthorized, *ImportChannelsForbidden, *ImportChannelsInternalServerError, error)

	QuerySessionHandler(params *QuerySessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*QuerySessionHandlerOK, *QuerySessionHandlerBadRequest, *QuerySessionHandlerUnauthorized, *QuerySessionHandlerForbidden, *QuerySessionHandlerNotFound, *QuerySessionHandlerInternalServerError, error)

	QueueSessionHandler(params *QueueSessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*QueueSessionHandlerNoContent, *QueueSessionHandlerBadRequest, *QueueSessionHandlerUnauthorized, *QueueSessionHandlerForbidden, *QueueSessionHandlerInternalServerError, error)

	SearchSessions(params *SearchSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*SearchSessionsOK, *SearchSessionsBadRequest, *SearchSessionsUnauthorized, *SearchSessionsForbidden, *SearchSessionsNotFound, *SearchSessionsInternalServerError, error)

	StoreMatchResults(params *StoreMatchResultsParams, authInfo runtime.ClientAuthInfoWriter) (*StoreMatchResultsOK, *StoreMatchResultsBadRequest, *StoreMatchResultsUnauthorized, *StoreMatchResultsForbidden, *StoreMatchResultsInternalServerError, error)

	UpdateMatchmakingChannel(params *UpdateMatchmakingChannelParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateMatchmakingChannelNoContent, *UpdateMatchmakingChannelBadRequest, *UpdateMatchmakingChannelUnauthorized, *UpdateMatchmakingChannelForbidden, *UpdateMatchmakingChannelNotFound, *UpdateMatchmakingChannelInternalServerError, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AddUserIntoSessionInChannel adds user into the session in a channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Create]

Required Scope: social

Add user into the session in a channel.
*/
func (a *Client) AddUserIntoSessionInChannel(params *AddUserIntoSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*AddUserIntoSessionInChannelOK, *AddUserIntoSessionInChannelBadRequest, *AddUserIntoSessionInChannelUnauthorized, *AddUserIntoSessionInChannelForbidden, *AddUserIntoSessionInChannelNotFound, *AddUserIntoSessionInChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddUserIntoSessionInChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AddUserIntoSessionInChannel",
		Method:             "POST",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}/sessions/{matchID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AddUserIntoSessionInChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AddUserIntoSessionInChannelOK:
		return v, nil, nil, nil, nil, nil, nil
	case *AddUserIntoSessionInChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *AddUserIntoSessionInChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *AddUserIntoSessionInChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *AddUserIntoSessionInChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *AddUserIntoSessionInChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  BulkGetSessions bulks get sessions

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Bulk get sessions.
*/
func (a *Client) BulkGetSessions(params *BulkGetSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*BulkGetSessionsOK, *BulkGetSessionsBadRequest, *BulkGetSessionsUnauthorized, *BulkGetSessionsForbidden, *BulkGetSessionsNotFound, *BulkGetSessionsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBulkGetSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "BulkGetSessions",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/all/sessions/bulk",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &BulkGetSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *BulkGetSessionsOK:
		return v, nil, nil, nil, nil, nil, nil
	case *BulkGetSessionsBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *BulkGetSessionsUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *BulkGetSessionsForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *BulkGetSessionsNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *BulkGetSessionsInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  CreateChannelHandler creates a channel

  Required Permission: NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [CREATE]

Required Scope: social

Creates a new matchmaking channel.

Matchmaking channels is a list of pool name that is eligible for matchmaking processes.
GameMode isolates each matchmaking pools.

If match timeout is set to 0, by default, incoming matchmaking requests will be timed out after 1 hour.

If max worker delay is set to 0, by default, it will wait for at max ~8 seconds during low volume.

Rule Set

Matching Rule used to classify the player. Player that has matched criteria will be grouped together within an ally.

Valid value for criteria is "distance"

*/
func (a *Client) CreateChannelHandler(params *CreateChannelHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateChannelHandlerCreated, *CreateChannelHandlerBadRequest, *CreateChannelHandlerUnauthorized, *CreateChannelHandlerForbidden, *CreateChannelHandlerConflict, *CreateChannelHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateChannelHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateChannelHandler",
		Method:             "POST",
		PathPattern:        "/matchmaking/namespaces/{namespace}/channels",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateChannelHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *CreateChannelHandlerCreated:
		return v, nil, nil, nil, nil, nil, nil
	case *CreateChannelHandlerBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *CreateChannelHandlerUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *CreateChannelHandlerForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *CreateChannelHandlerConflict:
		return nil, nil, nil, nil, v, nil, nil
	case *CreateChannelHandlerInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteChannelHandler deletes a channel

  Required Permission: NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Delete]

Required Scope: social

Deletes a matchmaking channel. Matchmaking channels is a list of
pool name that is eligible for matchmaking processes. GameMode isolates each matchmaking pools.

Trying to delete non-existent channel will result deletion success

*/
func (a *Client) DeleteChannelHandler(params *DeleteChannelHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteChannelHandlerNoContent, *DeleteChannelHandlerUnauthorized, *DeleteChannelHandlerForbidden, *DeleteChannelHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteChannelHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteChannelHandler",
		Method:             "DELETE",
		PathPattern:        "/matchmaking/namespaces/{namespace}/channels/{channel}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteChannelHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteChannelHandlerNoContent:
		return v, nil, nil, nil, nil
	case *DeleteChannelHandlerUnauthorized:
		return nil, v, nil, nil, nil
	case *DeleteChannelHandlerForbidden:
		return nil, nil, v, nil, nil
	case *DeleteChannelHandlerInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteSessionInChannel deletes session in a channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Delete]

Required Scope: social

Delete a session in a channel.
*/
func (a *Client) DeleteSessionInChannel(params *DeleteSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSessionInChannelNoContent, *DeleteSessionInChannelBadRequest, *DeleteSessionInChannelUnauthorized, *DeleteSessionInChannelForbidden, *DeleteSessionInChannelNotFound, *DeleteSessionInChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSessionInChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSessionInChannel",
		Method:             "DELETE",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}/sessions/{matchID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteSessionInChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteSessionInChannelNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *DeleteSessionInChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *DeleteSessionInChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *DeleteSessionInChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *DeleteSessionInChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *DeleteSessionInChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DeleteUserFromSessionInChannel deletes user from the session in a channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Delete]

Required Scope: social

Delete a user from a session in the channel.
*/
func (a *Client) DeleteUserFromSessionInChannel(params *DeleteUserFromSessionInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserFromSessionInChannelOK, *DeleteUserFromSessionInChannelNoContent, *DeleteUserFromSessionInChannelBadRequest, *DeleteUserFromSessionInChannelUnauthorized, *DeleteUserFromSessionInChannelForbidden, *DeleteUserFromSessionInChannelNotFound, *DeleteUserFromSessionInChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserFromSessionInChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteUserFromSessionInChannel",
		Method:             "DELETE",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}/sessions/{matchID}/users/{userID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteUserFromSessionInChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DeleteUserFromSessionInChannelOK:
		return v, nil, nil, nil, nil, nil, nil, nil
	case *DeleteUserFromSessionInChannelNoContent:
		return nil, v, nil, nil, nil, nil, nil, nil
	case *DeleteUserFromSessionInChannelBadRequest:
		return nil, nil, v, nil, nil, nil, nil, nil
	case *DeleteUserFromSessionInChannelUnauthorized:
		return nil, nil, nil, v, nil, nil, nil, nil
	case *DeleteUserFromSessionInChannelForbidden:
		return nil, nil, nil, nil, v, nil, nil, nil
	case *DeleteUserFromSessionInChannelNotFound:
		return nil, nil, nil, nil, nil, v, nil, nil
	case *DeleteUserFromSessionInChannelInternalServerError:
		return nil, nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  DequeueSessionHandler dequeues joinable session

  Required Permission: NAMESPACE:{namespace}:SESSION [UPDATE]

Required Scope: social

Dequeues joinable session so that it will not be matched with player's match request tickets.

This endpoint is intended to be called by game server to let matchmaker know that
the game server does not want more players to its session, even though it is not full.

*/
func (a *Client) DequeueSessionHandler(params *DequeueSessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*DequeueSessionHandlerNoContent, *DequeueSessionHandlerBadRequest, *DequeueSessionHandlerUnauthorized, *DequeueSessionHandlerForbidden, *DequeueSessionHandlerNotFound, *DequeueSessionHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDequeueSessionHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DequeueSessionHandler",
		Method:             "POST",
		PathPattern:        "/matchmaking/namespaces/{namespace}/sessions/dequeue",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DequeueSessionHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *DequeueSessionHandlerNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *DequeueSessionHandlerBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *DequeueSessionHandlerUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *DequeueSessionHandlerForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *DequeueSessionHandlerNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *DequeueSessionHandlerInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ExportChannels exports channels

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Export channels configuration to file.

Action Code: 510114
*/
func (a *Client) ExportChannels(params *ExportChannelsParams, authInfo runtime.ClientAuthInfoWriter) (*ExportChannelsOK, *ExportChannelsUnauthorized, *ExportChannelsForbidden, *ExportChannelsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportChannelsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExportChannels",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExportChannelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ExportChannelsOK:
		return v, nil, nil, nil, nil
	case *ExportChannelsUnauthorized:
		return nil, v, nil, nil, nil
	case *ExportChannelsForbidden:
		return nil, nil, v, nil, nil
	case *ExportChannelsInternalServerError:
		return nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllChannelsHandler gets all channels

  Required Permission: NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [READ]

Required Scope: social

Reads all available channels in a namespace

*/
func (a *Client) GetAllChannelsHandler(params *GetAllChannelsHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllChannelsHandlerOK, *GetAllChannelsHandlerBadRequest, *GetAllChannelsHandlerUnauthorized, *GetAllChannelsHandlerForbidden, *GetAllChannelsHandlerConflict, *GetAllChannelsHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllChannelsHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetAllChannelsHandler",
		Method:             "GET",
		PathPattern:        "/matchmaking/namespaces/{namespace}/channels",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllChannelsHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllChannelsHandlerOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetAllChannelsHandlerBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetAllChannelsHandlerUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetAllChannelsHandlerForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetAllChannelsHandlerConflict:
		return nil, nil, nil, nil, v, nil, nil
	case *GetAllChannelsHandlerInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllPartyInAllChannel gets all party in all channels

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Get all parties queueing in all channels.
*/
func (a *Client) GetAllPartyInAllChannel(params *GetAllPartyInAllChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllPartyInAllChannelOK, *GetAllPartyInAllChannelBadRequest, *GetAllPartyInAllChannelUnauthorized, *GetAllPartyInAllChannelForbidden, *GetAllPartyInAllChannelNotFound, *GetAllPartyInAllChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllPartyInAllChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetAllPartyInAllChannel",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/all/parties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllPartyInAllChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllPartyInAllChannelOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetAllPartyInAllChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetAllPartyInAllChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetAllPartyInAllChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetAllPartyInAllChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetAllPartyInAllChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllPartyInChannel gets all party in a channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Get all parties queueing in a channel.
*/
func (a *Client) GetAllPartyInChannel(params *GetAllPartyInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllPartyInChannelOK, *GetAllPartyInChannelBadRequest, *GetAllPartyInChannelUnauthorized, *GetAllPartyInChannelForbidden, *GetAllPartyInChannelNotFound, *GetAllPartyInChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllPartyInChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetAllPartyInChannel",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}/parties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllPartyInChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllPartyInChannelOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetAllPartyInChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetAllPartyInChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetAllPartyInChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetAllPartyInChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetAllPartyInChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetAllSessionsInChannel gets all channel sessions

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Get all sessions in a channel.
*/
func (a *Client) GetAllSessionsInChannel(params *GetAllSessionsInChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllSessionsInChannelOK, *GetAllSessionsInChannelBadRequest, *GetAllSessionsInChannelUnauthorized, *GetAllSessionsInChannelForbidden, *GetAllSessionsInChannelNotFound, *GetAllSessionsInChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllSessionsInChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetAllSessionsInChannel",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}/sessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAllSessionsInChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetAllSessionsInChannelOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetAllSessionsInChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetAllSessionsInChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetAllSessionsInChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetAllSessionsInChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetAllSessionsInChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetSessionHistoryDetailed gets session history detailed

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Get session history detailed.
*/
func (a *Client) GetSessionHistoryDetailed(params *GetSessionHistoryDetailedParams, authInfo runtime.ClientAuthInfoWriter) (*GetSessionHistoryDetailedOK, *GetSessionHistoryDetailedBadRequest, *GetSessionHistoryDetailedUnauthorized, *GetSessionHistoryDetailedForbidden, *GetSessionHistoryDetailedNotFound, *GetSessionHistoryDetailedInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSessionHistoryDetailedParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSessionHistoryDetailed",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/sessions/{matchID}/history/detailed",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSessionHistoryDetailedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetSessionHistoryDetailedOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetSessionHistoryDetailedBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetSessionHistoryDetailedUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetSessionHistoryDetailedForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetSessionHistoryDetailedNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetSessionHistoryDetailedInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  GetSingleMatchmakingChannel gets single channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [READ]

Required Scope: social

Reads single channel based on namespace and channel name

Action Code: 510112
*/
func (a *Client) GetSingleMatchmakingChannel(params *GetSingleMatchmakingChannelParams, authInfo runtime.ClientAuthInfoWriter) (*GetSingleMatchmakingChannelOK, *GetSingleMatchmakingChannelBadRequest, *GetSingleMatchmakingChannelUnauthorized, *GetSingleMatchmakingChannelForbidden, *GetSingleMatchmakingChannelNotFound, *GetSingleMatchmakingChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSingleMatchmakingChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSingleMatchmakingChannel",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSingleMatchmakingChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *GetSingleMatchmakingChannelOK:
		return v, nil, nil, nil, nil, nil, nil
	case *GetSingleMatchmakingChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *GetSingleMatchmakingChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *GetSingleMatchmakingChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *GetSingleMatchmakingChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *GetSingleMatchmakingChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  ImportChannels imports channels

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Update]

Required Scope: social

Import channels configuration from file. It will merge with existing channels.
Available import strategy:
- leaveOut: if channel with same key exist, the existing will be used and imported one will be ignored (default)
- replace: if channel with same key exist, the imported channel will be used and existing one will be removed

Action Code: 510113
*/
func (a *Client) ImportChannels(params *ImportChannelsParams, authInfo runtime.ClientAuthInfoWriter) (*ImportChannelsOK, *ImportChannelsBadRequest, *ImportChannelsUnauthorized, *ImportChannelsForbidden, *ImportChannelsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportChannelsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ImportChannels",
		Method:             "POST",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/import",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ImportChannelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *ImportChannelsOK:
		return v, nil, nil, nil, nil, nil
	case *ImportChannelsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *ImportChannelsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *ImportChannelsForbidden:
		return nil, nil, nil, v, nil, nil
	case *ImportChannelsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QuerySessionHandler queries joinable session status

  Required Permission: NAMESPACE:{namespace}:SESSION [READ]

Required Scope: social

Queries the specified session's status. Game servers are expected to
call this periodically as long as it has a session in queue to see
if there are new players being matched to the session.

Possible session statuses are "sessionInQueue", "sessionFull", and "sessionTimeout".

*/
func (a *Client) QuerySessionHandler(params *QuerySessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*QuerySessionHandlerOK, *QuerySessionHandlerBadRequest, *QuerySessionHandlerUnauthorized, *QuerySessionHandlerForbidden, *QuerySessionHandlerNotFound, *QuerySessionHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuerySessionHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "QuerySessionHandler",
		Method:             "GET",
		PathPattern:        "/matchmaking/namespaces/{namespace}/sessions/{matchID}/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuerySessionHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *QuerySessionHandlerOK:
		return v, nil, nil, nil, nil, nil, nil
	case *QuerySessionHandlerBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *QuerySessionHandlerUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *QuerySessionHandlerForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *QuerySessionHandlerNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *QuerySessionHandlerInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  QueueSessionHandler queues joinable session

  Required Permission: NAMESPACE:{namespace}:SESSION [CREATE]

Required Scope: social

Queues joinable session so that it will be matched with player's match request tickets.
The session queued must be in a channel/game mode that is set to have joinable flag.
The session will be in queue until it is full or expired.
Both the number of players and session queue timeout can be set in the channel's config.

This endpoint is intended to be called by game server to let matchmaker know that
the game server is ready for receiving more players through matchmaking tickets to its session.

If a session is already queued, and game server wants to modify the data or
renew the queue timeout (e.g. some player left and more empty slot opened up),
simply call this endpoint with the updated session data.

*/
func (a *Client) QueueSessionHandler(params *QueueSessionHandlerParams, authInfo runtime.ClientAuthInfoWriter) (*QueueSessionHandlerNoContent, *QueueSessionHandlerBadRequest, *QueueSessionHandlerUnauthorized, *QueueSessionHandlerForbidden, *QueueSessionHandlerInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueueSessionHandlerParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "QueueSessionHandler",
		Method:             "POST",
		PathPattern:        "/matchmaking/namespaces/{namespace}/sessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueueSessionHandlerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *QueueSessionHandlerNoContent:
		return v, nil, nil, nil, nil, nil
	case *QueueSessionHandlerBadRequest:
		return nil, v, nil, nil, nil, nil
	case *QueueSessionHandlerUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *QueueSessionHandlerForbidden:
		return nil, nil, nil, v, nil, nil
	case *QueueSessionHandlerInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  SearchSessions searches sessions

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Read]

Required Scope: social

Search sessions.
*/
func (a *Client) SearchSessions(params *SearchSessionsParams, authInfo runtime.ClientAuthInfoWriter) (*SearchSessionsOK, *SearchSessionsBadRequest, *SearchSessionsUnauthorized, *SearchSessionsForbidden, *SearchSessionsNotFound, *SearchSessionsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSearchSessionsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SearchSessions",
		Method:             "GET",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/sessions/history/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SearchSessionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *SearchSessionsOK:
		return v, nil, nil, nil, nil, nil, nil
	case *SearchSessionsBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *SearchSessionsUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *SearchSessionsForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *SearchSessionsNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *SearchSessionsInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  StoreMatchResults stores match result

  Required Permission: NAMESPACE:{namespace}:MATCHRESULT [CREATE]

Required Scope: social

Process match result into final attribute value and stores it to player attribute

Will return final attribute value

*/
func (a *Client) StoreMatchResults(params *StoreMatchResultsParams, authInfo runtime.ClientAuthInfoWriter) (*StoreMatchResultsOK, *StoreMatchResultsBadRequest, *StoreMatchResultsUnauthorized, *StoreMatchResultsForbidden, *StoreMatchResultsInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStoreMatchResultsParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StoreMatchResults",
		Method:             "POST",
		PathPattern:        "/matchmaking/namespaces/{namespace}/matchresult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &StoreMatchResultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *StoreMatchResultsOK:
		return v, nil, nil, nil, nil, nil
	case *StoreMatchResultsBadRequest:
		return nil, v, nil, nil, nil, nil
	case *StoreMatchResultsUnauthorized:
		return nil, nil, v, nil, nil, nil
	case *StoreMatchResultsForbidden:
		return nil, nil, nil, v, nil, nil
	case *StoreMatchResultsInternalServerError:
		return nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  UpdateMatchmakingChannel updates a channel

  Required Permission: ADMIN:NAMESPACE:{namespace}:MATCHMAKING:CHANNEL [Update]

Required Scope: social

Update channel based on namespace and channel name

Action Code: 510111
*/
func (a *Client) UpdateMatchmakingChannel(params *UpdateMatchmakingChannelParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateMatchmakingChannelNoContent, *UpdateMatchmakingChannelBadRequest, *UpdateMatchmakingChannelUnauthorized, *UpdateMatchmakingChannelForbidden, *UpdateMatchmakingChannelNotFound, *UpdateMatchmakingChannelInternalServerError, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMatchmakingChannelParams()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateMatchmakingChannel",
		Method:             "PATCH",
		PathPattern:        "/matchmaking/v1/admin/namespaces/{namespace}/channels/{channelName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateMatchmakingChannelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *UpdateMatchmakingChannelNoContent:
		return v, nil, nil, nil, nil, nil, nil
	case *UpdateMatchmakingChannelBadRequest:
		return nil, v, nil, nil, nil, nil, nil
	case *UpdateMatchmakingChannelUnauthorized:
		return nil, nil, v, nil, nil, nil, nil
	case *UpdateMatchmakingChannelForbidden:
		return nil, nil, nil, v, nil, nil, nil
	case *UpdateMatchmakingChannelNotFound:
		return nil, nil, nil, nil, v, nil, nil
	case *UpdateMatchmakingChannelInternalServerError:
		return nil, nil, nil, nil, nil, v, nil
	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
