// Copyright (c) 2021 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// Code generated by go-swagger; DO NOT EDIT.

package clients

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"reflect"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new clients API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for clients API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AdminAddClientPermissionsV3(params *AdminAddClientPermissionsV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminAddClientPermissionsV3NoContent, *AdminAddClientPermissionsV3BadRequest, *AdminAddClientPermissionsV3Unauthorized, *AdminAddClientPermissionsV3Forbidden, *AdminAddClientPermissionsV3NotFound, error)
	AdminAddClientPermissionsV3Short(params *AdminAddClientPermissionsV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminAddClientPermissionsV3NoContent, error)
	AdminCreateClientV3(params *AdminCreateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateClientV3Created, *AdminCreateClientV3BadRequest, *AdminCreateClientV3Unauthorized, *AdminCreateClientV3Forbidden, *AdminCreateClientV3Conflict, error)
	AdminCreateClientV3Short(params *AdminCreateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateClientV3Created, error)
	AdminDeleteClientPermissionV3(params *AdminDeleteClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientPermissionV3NoContent, *AdminDeleteClientPermissionV3BadRequest, *AdminDeleteClientPermissionV3Unauthorized, *AdminDeleteClientPermissionV3Forbidden, *AdminDeleteClientPermissionV3NotFound, error)
	AdminDeleteClientPermissionV3Short(params *AdminDeleteClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientPermissionV3NoContent, error)
	AdminDeleteClientV3(params *AdminDeleteClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientV3NoContent, *AdminDeleteClientV3BadRequest, *AdminDeleteClientV3Unauthorized, *AdminDeleteClientV3Forbidden, *AdminDeleteClientV3NotFound, *AdminDeleteClientV3Conflict, error)
	AdminDeleteClientV3Short(params *AdminDeleteClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientV3NoContent, error)
	AdminGetClientsByNamespaceV3(params *AdminGetClientsByNamespaceV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsByNamespaceV3OK, *AdminGetClientsByNamespaceV3BadRequest, *AdminGetClientsByNamespaceV3Unauthorized, *AdminGetClientsByNamespaceV3Forbidden, error)
	AdminGetClientsByNamespaceV3Short(params *AdminGetClientsByNamespaceV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsByNamespaceV3OK, error)
	AdminGetClientsbyNamespacebyIDV3(params *AdminGetClientsbyNamespacebyIDV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsbyNamespacebyIDV3OK, *AdminGetClientsbyNamespacebyIDV3BadRequest, *AdminGetClientsbyNamespacebyIDV3Unauthorized, *AdminGetClientsbyNamespacebyIDV3Forbidden, *AdminGetClientsbyNamespacebyIDV3NotFound, error)
	AdminGetClientsbyNamespacebyIDV3Short(params *AdminGetClientsbyNamespacebyIDV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsbyNamespacebyIDV3OK, error)
	AdminUpdateClientPermissionV3(params *AdminUpdateClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientPermissionV3NoContent, *AdminUpdateClientPermissionV3BadRequest, *AdminUpdateClientPermissionV3Unauthorized, *AdminUpdateClientPermissionV3Forbidden, *AdminUpdateClientPermissionV3NotFound, error)
	AdminUpdateClientPermissionV3Short(params *AdminUpdateClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientPermissionV3NoContent, error)
	AdminUpdateClientSecretV3(params *AdminUpdateClientSecretV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientSecretV3NoContent, *AdminUpdateClientSecretV3BadRequest, *AdminUpdateClientSecretV3Unauthorized, *AdminUpdateClientSecretV3Forbidden, *AdminUpdateClientSecretV3NotFound, error)
	AdminUpdateClientSecretV3Short(params *AdminUpdateClientSecretV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientSecretV3NoContent, error)
	AdminUpdateClientV3(params *AdminUpdateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientV3OK, *AdminUpdateClientV3BadRequest, *AdminUpdateClientV3Unauthorized, *AdminUpdateClientV3Forbidden, *AdminUpdateClientV3NotFound, error)
	AdminUpdateClientV3Short(params *AdminUpdateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientV3OK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
Deprecated: Use AdminAddClientPermissionsV3Short instead.

  AdminAddClientPermissionsV3 adds client permissions

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT&#39; [UPDATE]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10303&lt;/p&gt;

*/
func (a *Client) AdminAddClientPermissionsV3(params *AdminAddClientPermissionsV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminAddClientPermissionsV3NoContent, *AdminAddClientPermissionsV3BadRequest, *AdminAddClientPermissionsV3Unauthorized, *AdminAddClientPermissionsV3Forbidden, *AdminAddClientPermissionsV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAddClientPermissionsV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminAddClientPermissionsV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminAddClientPermissionsV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminAddClientPermissionsV3NoContent:
		return v, nil, nil, nil, nil, nil

	case *AdminAddClientPermissionsV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminAddClientPermissionsV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminAddClientPermissionsV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminAddClientPermissionsV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminAddClientPermissionsV3Short adds client permissions

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT&#39; [UPDATE]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10303&lt;/p&gt;

*/
func (a *Client) AdminAddClientPermissionsV3Short(params *AdminAddClientPermissionsV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminAddClientPermissionsV3NoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAddClientPermissionsV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminAddClientPermissionsV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminAddClientPermissionsV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminAddClientPermissionsV3NoContent:
		return v, nil
	case *AdminAddClientPermissionsV3BadRequest:
		return nil, v
	case *AdminAddClientPermissionsV3Unauthorized:
		return nil, v
	case *AdminAddClientPermissionsV3Forbidden:
		return nil, v
	case *AdminAddClientPermissionsV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminCreateClientV3Short instead.

  AdminCreateClientV3 creates client

  Add a new OAuth 2.0 client. Protected by the permission: ADMIN:NAMESPACE:{namespace}:CLIENT [CREATE]&lt;br&gt;
		A new client automatically granted with these scopes: commerce, account, analytics, publishing, social.&lt;br&gt;
		action code: 10301&lt;br&gt;
		&lt;p&gt;&lt;strong&gt;Fields Description:&lt;/strong&gt;
		&lt;ul&gt;
		&lt;li&gt;&lt;strong&gt;clientId&lt;/strong&gt; : The client ID. e.g f815e5c44f364993961be3b3f26a7bf4&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientName&lt;/strong&gt; : The client name. e.g E-commerce&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;secret&lt;/strong&gt; : The client&#39;s secret. It&#39;s empty if the client&#39;s type is a public client. Otherwise, the client secret is required&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;namespace&lt;/strong&gt; : The namespace where the client lives. e.g sample-game&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;redirectUri&lt;/strong&gt; : Contains the redirect URI used in OAuth callback. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;oauthClientType&lt;/strong&gt; : The OAuth 2.0 client type. The client type determines whether the authorization needs Proof Of Key Exchange or not.
					A public client type doesn&#39;t have a client secret and should use PKCE flow.
					A confidential client type has a client secret and don&#39;t use PKCE flow
			&lt;ul&gt;Supported oAuthClientType :
				&lt;li&gt;&lt;strong&gt;Public&lt;/strong&gt;&lt;/li&gt;
				&lt;li&gt;&lt;strong&gt;Confidential&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;audiences&lt;/strong&gt; : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;]&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;baseUri&lt;/strong&gt; : A base URI of the application. It is used for making sure the token is intended to be used by the client. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPermissions&lt;/strong&gt; : Contains the client&#39;s permissions&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;deletable&lt;/strong&gt; : The flag to identify whether client is deletable (optional). default value: true&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPlatform&lt;/strong&gt;: available client platform (optional). default value: &#34;&#34;
  			&lt;ul&gt;
				&lt;li&gt;Playstation&lt;/li&gt;
				&lt;li&gt;Xbox&lt;/li&gt;
				&lt;li&gt;Steam&lt;/li&gt;
				&lt;li&gt;Epic&lt;/li&gt;
				&lt;li&gt;IOS&lt;/li&gt;
				&lt;li&gt;GooglePlay&lt;/li&gt;
				&lt;li&gt;Nintendo&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/p&gt;

*/
func (a *Client) AdminCreateClientV3(params *AdminCreateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateClientV3Created, *AdminCreateClientV3BadRequest, *AdminCreateClientV3Unauthorized, *AdminCreateClientV3Forbidden, *AdminCreateClientV3Conflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminCreateClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminCreateClientV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminCreateClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminCreateClientV3Created:
		return v, nil, nil, nil, nil, nil

	case *AdminCreateClientV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminCreateClientV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminCreateClientV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminCreateClientV3Conflict:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminCreateClientV3Short creates client

  Add a new OAuth 2.0 client. Protected by the permission: ADMIN:NAMESPACE:{namespace}:CLIENT [CREATE]&lt;br&gt;
		A new client automatically granted with these scopes: commerce, account, analytics, publishing, social.&lt;br&gt;
		action code: 10301&lt;br&gt;
		&lt;p&gt;&lt;strong&gt;Fields Description:&lt;/strong&gt;
		&lt;ul&gt;
		&lt;li&gt;&lt;strong&gt;clientId&lt;/strong&gt; : The client ID. e.g f815e5c44f364993961be3b3f26a7bf4&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientName&lt;/strong&gt; : The client name. e.g E-commerce&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;secret&lt;/strong&gt; : The client&#39;s secret. It&#39;s empty if the client&#39;s type is a public client. Otherwise, the client secret is required&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;namespace&lt;/strong&gt; : The namespace where the client lives. e.g sample-game&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;redirectUri&lt;/strong&gt; : Contains the redirect URI used in OAuth callback. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;oauthClientType&lt;/strong&gt; : The OAuth 2.0 client type. The client type determines whether the authorization needs Proof Of Key Exchange or not.
					A public client type doesn&#39;t have a client secret and should use PKCE flow.
					A confidential client type has a client secret and don&#39;t use PKCE flow
			&lt;ul&gt;Supported oAuthClientType :
				&lt;li&gt;&lt;strong&gt;Public&lt;/strong&gt;&lt;/li&gt;
				&lt;li&gt;&lt;strong&gt;Confidential&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;audiences&lt;/strong&gt; : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;]&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;baseUri&lt;/strong&gt; : A base URI of the application. It is used for making sure the token is intended to be used by the client. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPermissions&lt;/strong&gt; : Contains the client&#39;s permissions&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;deletable&lt;/strong&gt; : The flag to identify whether client is deletable (optional). default value: true&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPlatform&lt;/strong&gt;: available client platform (optional). default value: &#34;&#34;
  			&lt;ul&gt;
				&lt;li&gt;Playstation&lt;/li&gt;
				&lt;li&gt;Xbox&lt;/li&gt;
				&lt;li&gt;Steam&lt;/li&gt;
				&lt;li&gt;Epic&lt;/li&gt;
				&lt;li&gt;IOS&lt;/li&gt;
				&lt;li&gt;GooglePlay&lt;/li&gt;
				&lt;li&gt;Nintendo&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/p&gt;

*/
func (a *Client) AdminCreateClientV3Short(params *AdminCreateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminCreateClientV3Created, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminCreateClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminCreateClientV3",
		Method:             "POST",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminCreateClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminCreateClientV3Created:
		return v, nil
	case *AdminCreateClientV3BadRequest:
		return nil, v
	case *AdminCreateClientV3Unauthorized:
		return nil, v
	case *AdminCreateClientV3Forbidden:
		return nil, v
	case *AdminCreateClientV3Conflict:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminDeleteClientPermissionV3Short instead.

  AdminDeleteClientPermissionV3 deletes client permission

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;br&gt;action code : 10304
*/
func (a *Client) AdminDeleteClientPermissionV3(params *AdminDeleteClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientPermissionV3NoContent, *AdminDeleteClientPermissionV3BadRequest, *AdminDeleteClientPermissionV3Unauthorized, *AdminDeleteClientPermissionV3Forbidden, *AdminDeleteClientPermissionV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminDeleteClientPermissionV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminDeleteClientPermissionV3",
		Method:             "DELETE",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions/{resource}/{action}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminDeleteClientPermissionV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminDeleteClientPermissionV3NoContent:
		return v, nil, nil, nil, nil, nil

	case *AdminDeleteClientPermissionV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminDeleteClientPermissionV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminDeleteClientPermissionV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminDeleteClientPermissionV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminDeleteClientPermissionV3Short deletes client permission

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;br&gt;action code : 10304
*/
func (a *Client) AdminDeleteClientPermissionV3Short(params *AdminDeleteClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientPermissionV3NoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminDeleteClientPermissionV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminDeleteClientPermissionV3",
		Method:             "DELETE",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions/{resource}/{action}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminDeleteClientPermissionV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminDeleteClientPermissionV3NoContent:
		return v, nil
	case *AdminDeleteClientPermissionV3BadRequest:
		return nil, v
	case *AdminDeleteClientPermissionV3Unauthorized:
		return nil, v
	case *AdminDeleteClientPermissionV3Forbidden:
		return nil, v
	case *AdminDeleteClientPermissionV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminDeleteClientV3Short instead.

  AdminDeleteClientV3 deletes client

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [DELETE]&#39;&lt;br&gt;action code : 10310
*/
func (a *Client) AdminDeleteClientV3(params *AdminDeleteClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientV3NoContent, *AdminDeleteClientV3BadRequest, *AdminDeleteClientV3Unauthorized, *AdminDeleteClientV3Forbidden, *AdminDeleteClientV3NotFound, *AdminDeleteClientV3Conflict, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminDeleteClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminDeleteClientV3",
		Method:             "DELETE",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminDeleteClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminDeleteClientV3NoContent:
		return v, nil, nil, nil, nil, nil, nil

	case *AdminDeleteClientV3BadRequest:
		return nil, v, nil, nil, nil, nil, nil

	case *AdminDeleteClientV3Unauthorized:
		return nil, nil, v, nil, nil, nil, nil

	case *AdminDeleteClientV3Forbidden:
		return nil, nil, nil, v, nil, nil, nil

	case *AdminDeleteClientV3NotFound:
		return nil, nil, nil, nil, v, nil, nil

	case *AdminDeleteClientV3Conflict:
		return nil, nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminDeleteClientV3Short deletes client

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [DELETE]&#39;&lt;br&gt;action code : 10310
*/
func (a *Client) AdminDeleteClientV3Short(params *AdminDeleteClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminDeleteClientV3NoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminDeleteClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminDeleteClientV3",
		Method:             "DELETE",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminDeleteClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminDeleteClientV3NoContent:
		return v, nil
	case *AdminDeleteClientV3BadRequest:
		return nil, v
	case *AdminDeleteClientV3Unauthorized:
		return nil, v
	case *AdminDeleteClientV3Forbidden:
		return nil, v
	case *AdminDeleteClientV3NotFound:
		return nil, v
	case *AdminDeleteClientV3Conflict:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminGetClientsByNamespaceV3Short instead.

  AdminGetClientsByNamespaceV3 gets clients by namespace

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [READ]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10308&lt;/p&gt;

*/
func (a *Client) AdminGetClientsByNamespaceV3(params *AdminGetClientsByNamespaceV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsByNamespaceV3OK, *AdminGetClientsByNamespaceV3BadRequest, *AdminGetClientsByNamespaceV3Unauthorized, *AdminGetClientsByNamespaceV3Forbidden, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminGetClientsByNamespaceV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminGetClientsByNamespaceV3",
		Method:             "GET",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminGetClientsByNamespaceV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminGetClientsByNamespaceV3OK:
		return v, nil, nil, nil, nil

	case *AdminGetClientsByNamespaceV3BadRequest:
		return nil, v, nil, nil, nil

	case *AdminGetClientsByNamespaceV3Unauthorized:
		return nil, nil, v, nil, nil

	case *AdminGetClientsByNamespaceV3Forbidden:
		return nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminGetClientsByNamespaceV3Short gets clients by namespace

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [READ]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10308&lt;/p&gt;

*/
func (a *Client) AdminGetClientsByNamespaceV3Short(params *AdminGetClientsByNamespaceV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsByNamespaceV3OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminGetClientsByNamespaceV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminGetClientsByNamespaceV3",
		Method:             "GET",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminGetClientsByNamespaceV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminGetClientsByNamespaceV3OK:
		return v, nil
	case *AdminGetClientsByNamespaceV3BadRequest:
		return nil, v
	case *AdminGetClientsByNamespaceV3Unauthorized:
		return nil, v
	case *AdminGetClientsByNamespaceV3Forbidden:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminGetClientsbyNamespacebyIDV3Short instead.

  AdminGetClientsbyNamespacebyIDV3 gets clients by namespace and client id

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [READ]&#39;&lt;br&gt;action code: 10309
*/
func (a *Client) AdminGetClientsbyNamespacebyIDV3(params *AdminGetClientsbyNamespacebyIDV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsbyNamespacebyIDV3OK, *AdminGetClientsbyNamespacebyIDV3BadRequest, *AdminGetClientsbyNamespacebyIDV3Unauthorized, *AdminGetClientsbyNamespacebyIDV3Forbidden, *AdminGetClientsbyNamespacebyIDV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminGetClientsbyNamespacebyIDV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminGetClientsbyNamespacebyIDV3",
		Method:             "GET",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminGetClientsbyNamespacebyIDV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminGetClientsbyNamespacebyIDV3OK:
		return v, nil, nil, nil, nil, nil

	case *AdminGetClientsbyNamespacebyIDV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminGetClientsbyNamespacebyIDV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminGetClientsbyNamespacebyIDV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminGetClientsbyNamespacebyIDV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminGetClientsbyNamespacebyIDV3Short gets clients by namespace and client id

  Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [READ]&#39;&lt;br&gt;action code: 10309
*/
func (a *Client) AdminGetClientsbyNamespacebyIDV3Short(params *AdminGetClientsbyNamespacebyIDV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminGetClientsbyNamespacebyIDV3OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminGetClientsbyNamespacebyIDV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminGetClientsbyNamespacebyIDV3",
		Method:             "GET",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminGetClientsbyNamespacebyIDV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminGetClientsbyNamespacebyIDV3OK:
		return v, nil
	case *AdminGetClientsbyNamespacebyIDV3BadRequest:
		return nil, v
	case *AdminGetClientsbyNamespacebyIDV3Unauthorized:
		return nil, v
	case *AdminGetClientsbyNamespacebyIDV3Forbidden:
		return nil, v
	case *AdminGetClientsbyNamespacebyIDV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminUpdateClientPermissionV3Short instead.

  AdminUpdateClientPermissionV3 updates client permissions

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10307&lt;/p&gt;

*/
func (a *Client) AdminUpdateClientPermissionV3(params *AdminUpdateClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientPermissionV3NoContent, *AdminUpdateClientPermissionV3BadRequest, *AdminUpdateClientPermissionV3Unauthorized, *AdminUpdateClientPermissionV3Forbidden, *AdminUpdateClientPermissionV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientPermissionV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientPermissionV3",
		Method:             "PUT",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientPermissionV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientPermissionV3NoContent:
		return v, nil, nil, nil, nil, nil

	case *AdminUpdateClientPermissionV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminUpdateClientPermissionV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminUpdateClientPermissionV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminUpdateClientPermissionV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateClientPermissionV3Short updates client permissions

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;/p&gt;
&lt;p&gt;action code: 10307&lt;/p&gt;

*/
func (a *Client) AdminUpdateClientPermissionV3Short(params *AdminUpdateClientPermissionV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientPermissionV3NoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientPermissionV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientPermissionV3",
		Method:             "PUT",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientPermissionV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientPermissionV3NoContent:
		return v, nil
	case *AdminUpdateClientPermissionV3BadRequest:
		return nil, v
	case *AdminUpdateClientPermissionV3Unauthorized:
		return nil, v
	case *AdminUpdateClientPermissionV3Forbidden:
		return nil, v
	case *AdminUpdateClientPermissionV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminUpdateClientSecretV3Short instead.

  AdminUpdateClientSecretV3 updates client secret

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;/br&gt;
*/
func (a *Client) AdminUpdateClientSecretV3(params *AdminUpdateClientSecretV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientSecretV3NoContent, *AdminUpdateClientSecretV3BadRequest, *AdminUpdateClientSecretV3Unauthorized, *AdminUpdateClientSecretV3Forbidden, *AdminUpdateClientSecretV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientSecretV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientSecretV3",
		Method:             "PUT",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/{clientId}/secret",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientSecretV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientSecretV3NoContent:
		return v, nil, nil, nil, nil, nil

	case *AdminUpdateClientSecretV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminUpdateClientSecretV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminUpdateClientSecretV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminUpdateClientSecretV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateClientSecretV3Short updates client secret

  &lt;p&gt;Required permission &#39;ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE]&#39;&lt;/br&gt;
*/
func (a *Client) AdminUpdateClientSecretV3Short(params *AdminUpdateClientSecretV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientSecretV3NoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientSecretV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientSecretV3",
		Method:             "PUT",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/{clientId}/secret",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientSecretV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientSecretV3NoContent:
		return v, nil
	case *AdminUpdateClientSecretV3BadRequest:
		return nil, v
	case *AdminUpdateClientSecretV3Unauthorized:
		return nil, v
	case *AdminUpdateClientSecretV3Forbidden:
		return nil, v
	case *AdminUpdateClientSecretV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
Deprecated: Use AdminUpdateClientV3Short instead.

  AdminUpdateClientV3 updates client

  Updates an OAuth 2.0 client. Protected by the permission: ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE].
				Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;}
		&lt;br&gt; action code: 10302&lt;br&gt;
		&lt;p&gt;&lt;strong&gt;Fields Description:&lt;/strong&gt;
		&lt;ul&gt;
		&lt;li&gt;&lt;strong&gt;clientName&lt;/strong&gt; : The client name. It should not be empty if the field exists in the body. e.g E-commerce&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;namespace&lt;/strong&gt; : The namespace where the client lives. e.g sample-game&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;redirectUri&lt;/strong&gt; : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body.  e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;audiences&lt;/strong&gt; : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;]&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;baseUri&lt;/strong&gt; : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPermissions&lt;/strong&gt; : Contains the client&#39;s permissions&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;deletable&lt;/strong&gt; : The flag to identify whether client is deletable (optional). e.g. true&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPlatform&lt;/strong&gt; : available client platform (optional). default value: &#34;&#34;.
  			&lt;ul&gt;
				&lt;li&gt;Playstation&lt;/li&gt;
				&lt;li&gt;Xbox&lt;/li&gt;
				&lt;li&gt;Steam&lt;/li&gt;
				&lt;li&gt;Epic&lt;/li&gt;
				&lt;li&gt;IOS&lt;/li&gt;
				&lt;li&gt;GooglePlay&lt;/li&gt;
				&lt;li&gt;Nintendo&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/p&gt;
*/
func (a *Client) AdminUpdateClientV3(params *AdminUpdateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientV3OK, *AdminUpdateClientV3BadRequest, *AdminUpdateClientV3Unauthorized, *AdminUpdateClientV3Forbidden, *AdminUpdateClientV3NotFound, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientV3",
		Method:             "PATCH",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, nil, nil, nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientV3OK:
		return v, nil, nil, nil, nil, nil

	case *AdminUpdateClientV3BadRequest:
		return nil, v, nil, nil, nil, nil

	case *AdminUpdateClientV3Unauthorized:
		return nil, nil, v, nil, nil, nil

	case *AdminUpdateClientV3Forbidden:
		return nil, nil, nil, v, nil, nil

	case *AdminUpdateClientV3NotFound:
		return nil, nil, nil, nil, v, nil

	default:
		return nil, nil, nil, nil, nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

/*
  AdminUpdateClientV3Short updates client

  Updates an OAuth 2.0 client. Protected by the permission: ADMIN:NAMESPACE:{namespace}:CLIENT [UPDATE].
				Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;}
		&lt;br&gt; action code: 10302&lt;br&gt;
		&lt;p&gt;&lt;strong&gt;Fields Description:&lt;/strong&gt;
		&lt;ul&gt;
		&lt;li&gt;&lt;strong&gt;clientName&lt;/strong&gt; : The client name. It should not be empty if the field exists in the body. e.g E-commerce&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;namespace&lt;/strong&gt; : The namespace where the client lives. e.g sample-game&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;redirectUri&lt;/strong&gt; : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body.  e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;audiences&lt;/strong&gt; : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;]&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;baseUri&lt;/strong&gt; : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPermissions&lt;/strong&gt; : Contains the client&#39;s permissions&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;deletable&lt;/strong&gt; : The flag to identify whether client is deletable (optional). e.g. true&lt;/li&gt;
		&lt;li&gt;&lt;strong&gt;clientPlatform&lt;/strong&gt; : available client platform (optional). default value: &#34;&#34;.
  			&lt;ul&gt;
				&lt;li&gt;Playstation&lt;/li&gt;
				&lt;li&gt;Xbox&lt;/li&gt;
				&lt;li&gt;Steam&lt;/li&gt;
				&lt;li&gt;Epic&lt;/li&gt;
				&lt;li&gt;IOS&lt;/li&gt;
				&lt;li&gt;GooglePlay&lt;/li&gt;
				&lt;li&gt;Nintendo&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/p&gt;
*/
func (a *Client) AdminUpdateClientV3Short(params *AdminUpdateClientV3Params, authInfo runtime.ClientAuthInfoWriter) (*AdminUpdateClientV3OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminUpdateClientV3Params()
	}

	if params.Context == nil {
		params.Context = context.Background()
	}

	if params.RetryPolicy != nil {
		params.SetHTTPClientTransport(params.RetryPolicy)
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AdminUpdateClientV3",
		Method:             "PATCH",
		PathPattern:        "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AdminUpdateClientV3Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}

	switch v := result.(type) {

	case *AdminUpdateClientV3OK:
		return v, nil
	case *AdminUpdateClientV3BadRequest:
		return nil, v
	case *AdminUpdateClientV3Unauthorized:
		return nil, v
	case *AdminUpdateClientV3Forbidden:
		return nil, v
	case *AdminUpdateClientV3NotFound:
		return nil, v

	default:
		return nil, fmt.Errorf("Unexpected Type %v", reflect.TypeOf(v))
	}
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
